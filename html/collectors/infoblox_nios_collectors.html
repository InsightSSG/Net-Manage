<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>collectors.infoblox_nios_collectors API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>collectors.infoblox_nios_collectors</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import ipaddress as ip
import pandas as pd
from netmanage.helpers import helpers as hp
from infoblox_client import connector


def create_connector(host: str,
                     username: str,
                     password: str,
                     validate_certs: bool = True) -&gt; connector.Connector:
    &#39;&#39;&#39;
    Creates the connector to use to connect to the Infoblox grid.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Notes
    -----
    If &#39;validate_certs=False&#39;, then &#39;silent_ssl_warnings&#39; will be set to
    &#39;True&#39;.

    Returns
    -------
    nb : infoblox_client.connector.Connector
        The Infoblox Connector object.

    Other Parameters
    ----------------
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;

    Examples
    --------
    &gt;&gt;&gt; conn = create_connector(host, username, password)
    &gt;&gt;&gt; print(type(conn))
    &lt;class &#39;infoblox_client.connector.Connector&#39;&gt;
    &#39;&#39;&#39;
    opts = {&#39;host&#39;: host,
            &#39;username&#39;: username,
            &#39;password&#39;: password,
            &#39;ssl_verify&#39;: validate_certs}
    if not validate_certs:
        opts[&#39;silent_ssl_warnings&#39;] = True
    conn = connector.Connector(opts)
    return conn


def get_network_containers(host: str,
                           username: str,
                           password: str,
                           paging: bool = True,
                           validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all network containers.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the network containers.

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;

    Examples
    --------
    &gt;&gt;&gt; df = get_network_containers(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;networkcontainer&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key, value in item.items():
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data)

    return df


def get_networks_parent_containers(db_path: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets the parent containers for all networks in an Infoblox Grid.

    This function does not connect to the Infoblox grid. Instead, it uses
    the database to map networks to their parent container.

    TODO: Test results when networks are under nested containers.

    Parameters
    ----------
    db_path : str
        The path to the database which contains the &#39;GET_NETWORKS&#39; and
        &#39;GET_NETWORK_CONTAINER&#39; tables.

    Returns:
    df : pd.Dataframe:
        A dataframe containing the network container for each network.

    Examples
    ----------
    &gt;&gt;&gt; df = get_networks_parent_containers(db_path)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Connect to the database
    con = hp.connect_to_db(db_path)

    # Get the last timestamp for each network in the &#39;GET_NETWORKS&#39; table.
    # (This function is always run after the &#39;get_networks&#39; and
    # &#39;get_network_containers&#39; collectors, so we only need the timestamp for
    # one of the tables.)
    table = &#39;INFOBLOX_GET_NETWORKS&#39;
    query = f&#39;SELECT DISTINCT timestamp FROM {table}&#39;
    last_ts = pd.read_sql(query, con)[&#39;timestamp&#39;].to_list()[-1]

    # Get all the networks
    query = [&#39;SELECT network, network_view&#39;,
             f&#39;FROM {table}&#39;,
             f&#39;WHERE timestamp = &#34;{last_ts}&#34;&#39;]
    query = &#39; &#39;.join(query)
    df = pd.read_sql(query, con)

    # Get all the network containers
    table = &#39;INFOBLOX_GET_NETWORK_CONTAINERS&#39;
    query = [&#39;SELECT network, network_view&#39;,
             f&#39;FROM {table}&#39;,
             f&#39;WHERE timestamp = &#34;{last_ts}&#34;&#39;]
    query = &#39; &#39;.join(query)
    df_containers = pd.read_sql(query, con)

    # Create a list of distinct network views
    views = df_containers[&#39;network_view&#39;].to_list()
    views = [*set(views)]

    # Create a dictionary of the containers, where each key is a unique view,
    # and the value is a list of network containers, sorted from smallest to
    # largest
    containers = dict()
    for view in views:
        u_containers = df_containers.loc[df_containers[&#39;network_view&#39;] == view]
        u_containers = u_containers[&#39;network&#39;].to_list()
        u_containers = [ip.ip_network(_, strict=False) for _ in u_containers]
        u_containers = sorted(u_containers, key=ip.ip_network, reverse=True)
        containers[view] = u_containers

    # Iterate over the networks, mapping each network to its parent container
    # for its view. Infoblox supports nested containers, so the loop breaks
    # when the first valid parent is reached. (That is why &#39;u_containers&#39; for
    # each view is sorted from the smallest to largest container.)
    parent_containers = list()
    not_found = list()
    for idx, row in df.iterrows():
        found = False
        network = ip.ip_network(row[&#39;network&#39;], strict=False)
        view = row[&#39;network_view&#39;]
        for container in containers[view]:
            if network.subnet_of(container):
                parent_containers.append(str(container))
                found = True
                break
        if not found:
            parent_containers.append(&#39;orphan&#39;)
            not_found.append(network)

    # Add the parent containers to &#39;df_networks&#39;
    df[&#39;network_container&#39;] = parent_containers

    return df


def get_networks(host: str,
                 username: str,
                 password: str,
                 paging: bool = True,
                 validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all networks.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the networks

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;

    Examples
    --------
    &gt;&gt;&gt; df = get_networks(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;network&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key, value in item.items():
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data)

    return df


def get_vlan_ranges(host: str,
                    username: str,
                    password: str,
                    paging: bool = True,
                    validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all VLAN ranges.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the VLAN ranges.

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;.

    Examples
    --------
    &gt;&gt;&gt; df = get_vlan_ranges(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;vlanrange&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key in item:
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data).astype(&#39;str&#39;)

    return df


def get_vlans(host: str,
              username: str,
              password: str,
              paging: bool = True,
              validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all VLANs.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the VLAN ranges.

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;.

    Examples
    --------
    &gt;&gt;&gt; df = get_vlan_ranges(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;vlan&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key in item:
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data).astype(&#39;str&#39;)

    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="collectors.infoblox_nios_collectors.create_connector"><code class="name flex">
<span>def <span class="ident">create_connector</span></span>(<span>host: str, username: str, password: str, validate_certs: bool = True) ‑> infoblox_client.connector.Connector</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the connector to use to connect to the Infoblox grid.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host's IP address or FQDN</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's password.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>If 'validate_certs=False', then 'silent_ssl_warnings' will be set to
'True'.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nb</code></strong> :&ensp;<code>infoblox_client.connector.Connector</code></dt>
<dd>The Infoblox Connector object.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>validate_certs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to validate certificates. Defaults to 'True'</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; conn = create_connector(host, username, password)
&gt;&gt;&gt; print(type(conn))
&lt;class 'infoblox_client.connector.Connector'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_connector(host: str,
                     username: str,
                     password: str,
                     validate_certs: bool = True) -&gt; connector.Connector:
    &#39;&#39;&#39;
    Creates the connector to use to connect to the Infoblox grid.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Notes
    -----
    If &#39;validate_certs=False&#39;, then &#39;silent_ssl_warnings&#39; will be set to
    &#39;True&#39;.

    Returns
    -------
    nb : infoblox_client.connector.Connector
        The Infoblox Connector object.

    Other Parameters
    ----------------
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;

    Examples
    --------
    &gt;&gt;&gt; conn = create_connector(host, username, password)
    &gt;&gt;&gt; print(type(conn))
    &lt;class &#39;infoblox_client.connector.Connector&#39;&gt;
    &#39;&#39;&#39;
    opts = {&#39;host&#39;: host,
            &#39;username&#39;: username,
            &#39;password&#39;: password,
            &#39;ssl_verify&#39;: validate_certs}
    if not validate_certs:
        opts[&#39;silent_ssl_warnings&#39;] = True
    conn = connector.Connector(opts)
    return conn</code></pre>
</details>
</dd>
<dt id="collectors.infoblox_nios_collectors.get_network_containers"><code class="name flex">
<span>def <span class="ident">get_network_containers</span></span>(<span>host: str, username: str, password: str, paging: bool = True, validate_certs: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all network containers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host's IP address or FQDN</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's password.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A Pandas dataframe containing the network containers.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>paging</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform paging. Defaults to True.</dd>
<dt><strong><code>validate_certs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to validate certificates. Defaults to 'True'</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = get_network_containers(host, username, password)
&gt;&gt;&gt; print(type(df))
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_network_containers(host: str,
                           username: str,
                           password: str,
                           paging: bool = True,
                           validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all network containers.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the network containers.

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;

    Examples
    --------
    &gt;&gt;&gt; df = get_network_containers(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;networkcontainer&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key, value in item.items():
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data)

    return df</code></pre>
</details>
</dd>
<dt id="collectors.infoblox_nios_collectors.get_networks"><code class="name flex">
<span>def <span class="ident">get_networks</span></span>(<span>host: str, username: str, password: str, paging: bool = True, validate_certs: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all networks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host's IP address or FQDN</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's password.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A Pandas dataframe containing the networks</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>paging</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform paging. Defaults to True.</dd>
<dt><strong><code>validate_certs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to validate certificates. Defaults to 'True'</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = get_networks(host, username, password)
&gt;&gt;&gt; print(type(df))
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_networks(host: str,
                 username: str,
                 password: str,
                 paging: bool = True,
                 validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all networks.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the networks

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;

    Examples
    --------
    &gt;&gt;&gt; df = get_networks(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;network&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key, value in item.items():
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data)

    return df</code></pre>
</details>
</dd>
<dt id="collectors.infoblox_nios_collectors.get_networks_parent_containers"><code class="name flex">
<span>def <span class="ident">get_networks_parent_containers</span></span>(<span>db_path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the parent containers for all networks in an Infoblox Grid.</p>
<p>This function does not connect to the Infoblox grid. Instead, it uses
the database to map networks to their parent container.</p>
<p>TODO: Test results when networks are under nested containers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database which contains the 'GET_NETWORKS' and
'GET_NETWORK_CONTAINER' tables.</dd>
<dt>Returns:</dt>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.Dataframe:</code></dt>
<dd>A dataframe containing the network container for each network.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = get_networks_parent_containers(db_path)
&gt;&gt;&gt; print(type(df))
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_networks_parent_containers(db_path: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets the parent containers for all networks in an Infoblox Grid.

    This function does not connect to the Infoblox grid. Instead, it uses
    the database to map networks to their parent container.

    TODO: Test results when networks are under nested containers.

    Parameters
    ----------
    db_path : str
        The path to the database which contains the &#39;GET_NETWORKS&#39; and
        &#39;GET_NETWORK_CONTAINER&#39; tables.

    Returns:
    df : pd.Dataframe:
        A dataframe containing the network container for each network.

    Examples
    ----------
    &gt;&gt;&gt; df = get_networks_parent_containers(db_path)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Connect to the database
    con = hp.connect_to_db(db_path)

    # Get the last timestamp for each network in the &#39;GET_NETWORKS&#39; table.
    # (This function is always run after the &#39;get_networks&#39; and
    # &#39;get_network_containers&#39; collectors, so we only need the timestamp for
    # one of the tables.)
    table = &#39;INFOBLOX_GET_NETWORKS&#39;
    query = f&#39;SELECT DISTINCT timestamp FROM {table}&#39;
    last_ts = pd.read_sql(query, con)[&#39;timestamp&#39;].to_list()[-1]

    # Get all the networks
    query = [&#39;SELECT network, network_view&#39;,
             f&#39;FROM {table}&#39;,
             f&#39;WHERE timestamp = &#34;{last_ts}&#34;&#39;]
    query = &#39; &#39;.join(query)
    df = pd.read_sql(query, con)

    # Get all the network containers
    table = &#39;INFOBLOX_GET_NETWORK_CONTAINERS&#39;
    query = [&#39;SELECT network, network_view&#39;,
             f&#39;FROM {table}&#39;,
             f&#39;WHERE timestamp = &#34;{last_ts}&#34;&#39;]
    query = &#39; &#39;.join(query)
    df_containers = pd.read_sql(query, con)

    # Create a list of distinct network views
    views = df_containers[&#39;network_view&#39;].to_list()
    views = [*set(views)]

    # Create a dictionary of the containers, where each key is a unique view,
    # and the value is a list of network containers, sorted from smallest to
    # largest
    containers = dict()
    for view in views:
        u_containers = df_containers.loc[df_containers[&#39;network_view&#39;] == view]
        u_containers = u_containers[&#39;network&#39;].to_list()
        u_containers = [ip.ip_network(_, strict=False) for _ in u_containers]
        u_containers = sorted(u_containers, key=ip.ip_network, reverse=True)
        containers[view] = u_containers

    # Iterate over the networks, mapping each network to its parent container
    # for its view. Infoblox supports nested containers, so the loop breaks
    # when the first valid parent is reached. (That is why &#39;u_containers&#39; for
    # each view is sorted from the smallest to largest container.)
    parent_containers = list()
    not_found = list()
    for idx, row in df.iterrows():
        found = False
        network = ip.ip_network(row[&#39;network&#39;], strict=False)
        view = row[&#39;network_view&#39;]
        for container in containers[view]:
            if network.subnet_of(container):
                parent_containers.append(str(container))
                found = True
                break
        if not found:
            parent_containers.append(&#39;orphan&#39;)
            not_found.append(network)

    # Add the parent containers to &#39;df_networks&#39;
    df[&#39;network_container&#39;] = parent_containers

    return df</code></pre>
</details>
</dd>
<dt id="collectors.infoblox_nios_collectors.get_vlan_ranges"><code class="name flex">
<span>def <span class="ident">get_vlan_ranges</span></span>(<span>host: str, username: str, password: str, paging: bool = True, validate_certs: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all VLAN ranges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host's IP address or FQDN</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's password.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A Pandas dataframe containing the VLAN ranges.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>paging</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform paging. Defaults to True.</dd>
<dt><strong><code>validate_certs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to validate certificates. Defaults to 'True'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = get_vlan_ranges(host, username, password)
&gt;&gt;&gt; print(type(df))
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vlan_ranges(host: str,
                    username: str,
                    password: str,
                    paging: bool = True,
                    validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all VLAN ranges.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the VLAN ranges.

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;.

    Examples
    --------
    &gt;&gt;&gt; df = get_vlan_ranges(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;vlanrange&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key in item:
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data).astype(&#39;str&#39;)

    return df</code></pre>
</details>
</dd>
<dt id="collectors.infoblox_nios_collectors.get_vlans"><code class="name flex">
<span>def <span class="ident">get_vlans</span></span>(<span>host: str, username: str, password: str, paging: bool = True, validate_certs: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all VLANs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>The host's IP address or FQDN</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's password.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A Pandas dataframe containing the VLAN ranges.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>paging</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to perform paging. Defaults to True.</dd>
<dt><strong><code>validate_certs</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to validate certificates. Defaults to 'True'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = get_vlan_ranges(host, username, password)
&gt;&gt;&gt; print(type(df))
&lt;class 'pandas.core.frame.DataFrame'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vlans(host: str,
              username: str,
              password: str,
              paging: bool = True,
              validate_certs: bool = True) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets all VLANs.

    Parameters
    ----------
    host : str
        The host&#39;s IP address or FQDN
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the VLAN ranges.

    Other Parameters
    ----------------
    paging: bool, optional
        Whether to perform paging. Defaults to True.
    validate_certs: bool, optional
        Whether to validate certificates. Defaults to &#39;True&#39;.

    Examples
    --------
    &gt;&gt;&gt; df = get_vlan_ranges(host, username, password)
    &gt;&gt;&gt; print(type(df))
    &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
    &#39;&#39;&#39;
    # Create the connector to use to connect to the API
    conn = create_connector(host,
                            username,
                            password,
                            validate_certs=validate_certs)

    # Get the network containers
    response = conn.get_object(&#39;vlan&#39;, paging=paging)

    # Create the dictionary to store the data needed to create the DataFrame,
    # then interate over &#39;response&#39; to create the keys
    df_data = dict()
    for item in response:
        for key in item:
            df_data[key] = list()

    # Populate &#39;df_data&#39;
    for item in response:
        for key in df_data:
            df_data[key].append(item.get(key))

    df = pd.DataFrame.from_dict(df_data).astype(&#39;str&#39;)

    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="collectors" href="index.html">collectors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="collectors.infoblox_nios_collectors.create_connector" href="#collectors.infoblox_nios_collectors.create_connector">create_connector</a></code></li>
<li><code><a title="collectors.infoblox_nios_collectors.get_network_containers" href="#collectors.infoblox_nios_collectors.get_network_containers">get_network_containers</a></code></li>
<li><code><a title="collectors.infoblox_nios_collectors.get_networks" href="#collectors.infoblox_nios_collectors.get_networks">get_networks</a></code></li>
<li><code><a title="collectors.infoblox_nios_collectors.get_networks_parent_containers" href="#collectors.infoblox_nios_collectors.get_networks_parent_containers">get_networks_parent_containers</a></code></li>
<li><code><a title="collectors.infoblox_nios_collectors.get_vlan_ranges" href="#collectors.infoblox_nios_collectors.get_vlan_ranges">get_vlan_ranges</a></code></li>
<li><code><a title="collectors.infoblox_nios_collectors.get_vlans" href="#collectors.infoblox_nios_collectors.get_vlans">get_vlans</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>