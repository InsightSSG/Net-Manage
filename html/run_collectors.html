<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>run_collectors API documentation</title>
<meta name="description" content="Define collectors and map them to the correct function in colletors.py." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>run_collectors</code></h1>
</header>
<section id="section-intro">
<p>Define collectors and map them to the correct function in colletors.py.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#39;&#39;&#39;
Define collectors and map them to the correct function in colletors.py.
&#39;&#39;&#39;

import argparse
import ast
# import asyncio  # Temporarily disabled; does not work inside iPython.
import datetime as dt
import os
import pandas as pd
import readline
from netmanage.collectors import cisco_asa_collectors as cac
from netmanage.collectors import cisco_ios_collectors as cic
from netmanage.collectors import cisco_nxos_collectors as cnc
from netmanage.collectors import dnac_collectors as dnc
from netmanage.collectors import f5_collectors as f5c
from netmanage.collectors import infoblox_nios_collectors as nc
from netmanage.collectors import meraki_collectors as mc
from netmanage.collectors import netbox_collectors as nbc
from netmanage.collectors import palo_alto_collectors as pac
from netmanage.collectors import solarwinds_collectors as swc
from dotenv import load_dotenv
from netmanage.helpers import helpers as hp
from typing import List

# Load environment variables.
load_dotenv()

# Protect creds by not writing history to .python_history.
readline.write_history_file = lambda *args: None


def collect(ansible_os: str,
            collector: str,
            hostgroup: str,
            timestamp: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    This function calls the test that the user requested.

    Parameters
    ----------
    ansible_os : str
        The Ansible OS of the hostgroup.
    collector : str
        The name of the collector that the user requested.
    hostgroup : str
        The name of the Ansible hostgroup.
    timestamp : str
        The timestamp is YYYY-MM-DD_hhmm format.

    Returns
    -------
    result : pd.DataFrame
        A DataFrame containing the data from the collector.
    &#39;&#39;&#39;
    # Read global variables
    database_name = os.environ[&#39;database_name&#39;]
    database_path = os.path.expanduser(os.environ[&#39;database_path&#39;])
    netmanage_path = os.path.expanduser(
        os.environ[&#39;netmanage_path&#39;].rstrip(&#39;/&#39;))
    private_data_dir = os.path.expanduser(
        os.environ[&#39;private_data_directory&#39;])
    validate_certs = ast.literal_eval(os.environ[&#39;validate_certs&#39;])
    database_method = os.environ[&#39;database_method&#39;]

    # Read Cisco ASA variables
    asa_devices_username = os.environ[&#39;asa_devices_username&#39;]
    asa_devices_password = os.environ[&#39;asa_devices_password&#39;]

    # Read Cisco DNAC variables
    dnac_url = os.environ[&#39;dnac_url&#39;]
    dnac_username = os.environ[&#39;dnac_username&#39;]
    dnac_password = os.environ[&#39;dnac_password&#39;]
    dnac_platform_ids = list(
        filter(None, os.environ[&#39;dnac_platform_ids&#39;].split(&#39;,&#39;)))

    # Read Cisco IOS variables
    ios_devices_username = os.environ[&#39;ios_devices_username&#39;]
    ios_devices_password = os.environ[&#39;ios_devices_password&#39;]

    # Read Cisco NXOS variables
    nxos_devices_username = os.environ[&#39;nxos_devices_username&#39;]
    nxos_devices_password = os.environ[&#39;nxos_devices_password&#39;]

    # Read F5 LTM variables
    f5_ltm_username = os.environ[&#39;f5_ltm_username&#39;]
    f5_ltm_password = os.environ[&#39;f5_ltm_password&#39;]
    # f5_log_range = os.environ[&#39;f5_log_range&#39;]
    # f5_log_type = os.environ[&#39;f5_log_type&#39;]
    # f5_num_lines = os.environ[&#39;f5_num_lines&#39;]

    # Read Infoblox variables
    infoblox_url = os.environ[&#39;infoblox_url&#39;]
    infoblox_username = os.environ[&#39;infoblox_username&#39;]
    infoblox_password = os.environ[&#39;infoblox_password&#39;]
    infoblox_paging = os.environ[&#39;infoblox_paging&#39;]

    # Read Meraki variables
    meraki_api_key = os.environ[&#39;meraki_api_key&#39;]
    meraki_networks = list(filter(
        None, os.environ[&#39;meraki_networks&#39;].split(&#39;,&#39;)))
    meraki_organizations = list(filter(
        None, os.environ[&#39;meraki_organizations&#39;].split(&#39;,&#39;)))
    meraki_serials = list(filter(
        None, os.environ[&#39;meraki_serials&#39;].split(&#39;,&#39;)))
    meraki_serials = [_.strip() for _ in meraki_serials]
    try:
        meraki_tp = int(os.environ[&#39;meraki_total_pages&#39;])
    except ValueError:
        meraki_tp = -1
    # These 3 variables are temporarily commented out until we re-enable the
    # asyncio collectors.
    # meraki_macs = os.environ[&#39;meraki_macs&#39;]
    # meraki_lookback = os.environ[&#39;meraki_lookback_timespan&#39;]
    # meraki_per_page = os.environ[&#39;meraki_per_page&#39;]

    # Read Netbox variables
    netbox_url = os.environ[&#39;netbox_url&#39;]
    netbox_token = os.environ[&#39;netbox_token&#39;]

    # Read Palo Alto variables
    palo_alto_username = os.environ[&#39;palo_alto_username&#39;]
    palo_alto_password = os.environ[&#39;palo_alto_password&#39;]

    # Read Solarwinds NPM variables
    npm_server = os.environ[&#39;solarwinds_npm_server&#39;]
    npm_username = os.environ[&#39;solarwinds_npm_username&#39;]
    npm_password = os.environ[&#39;solarwinds_npm_password&#39;]
    npm_group_name = os.environ[&#39;solarwinds_npm_group_name&#39;]

    # Create the output folder if it does not already exist.
    exists = hp.check_dir_existence(database_path)
    if not exists:
        hp.create_dir(database_path)

    # Define additional variables
    database_full_path = f&#39;{database_path}/{database_name}&#39;
    idx_cols = list()
    play_path = netmanage_path + &#39;/playbooks&#39;

    # Create an empty DataFrame for when collectors return no results.
    result = pd.DataFrame()

    # Call collector and return results.
    if ansible_os == &#39;bigip&#39;:
        if collector == &#39;arp_table&#39;:
            result = f5c.get_arp_table(f5_ltm_username,
                                       f5_ltm_password,
                                       hostgroup,
                                       netmanage_path,
                                       play_path,
                                       private_data_dir,
                                       validate_certs=validate_certs)

        if collector == &#39;interface_description&#39;:
            result = f5c.\
                get_interface_descriptions(f5_ltm_username,
                                           f5_ltm_password,
                                           hostgroup,
                                           netmanage_path,
                                           play_path,
                                           private_data_dir,
                                           reverse_dns=False,
                                           validate_certs=validate_certs)

        if collector == &#39;interface_summary&#39;:
            result = f5c.get_interface_status(f5_ltm_username,
                                              f5_ltm_password,
                                              hostgroup,
                                              play_path,
                                              private_data_dir,
                                              validate_certs=validate_certs)

        # Do not uncomment the &#39;logs&#39; collector until it is updated to use
        # bash. This is because of a suspected F5 bug that causes the active
        # unit to sometimes hang when retrieving the logs with a tmsh command
        # (Ansible) or a REST API call.

        # if collector == &#39;logs&#39;:
        #     result = f5c.get_log_files(f5_ltm_username,
        #                                f5_ltm_password,
        #                                hostgroup,
        #                                play_path,
        #                                private_data_dir,
        #                                log_type=f5_log_type,
        #                                log_range=f5_log_range,
        #                                num_lines=f5_num_lines,
        #                                validate_certs=validate_certs)

        if collector == &#39;node_availability&#39;:
            result = f5c.get_node_availability(f5_ltm_username,
                                               f5_ltm_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir,
                                               validate_certs=validate_certs)

        if collector == &#39;pool_availability&#39;:
            result = f5c.get_pool_availability(f5_ltm_username,
                                               f5_ltm_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir,
                                               validate_certs=validate_certs)

        if collector == &#39;pool_summary&#39;:
            result = f5c.get_pool_data(f5_ltm_username,
                                       f5_ltm_password,
                                       hostgroup,
                                       play_path,
                                       private_data_dir,
                                       validate_certs=validate_certs)

        if collector == &#39;pool_member_availability&#39;:
            result = f5c.\
                get_pool_member_availability(f5_ltm_username,
                                             f5_ltm_password,
                                             hostgroup,
                                             play_path,
                                             private_data_dir,
                                             validate_certs=validate_certs)

        if collector == &#39;self_ips&#39;:
            result = f5c.get_self_ips(f5_ltm_username,
                                      f5_ltm_password,
                                      hostgroup,
                                      play_path,
                                      private_data_dir,
                                      validate_certs=validate_certs)

        if collector == &#39;vip_availability&#39;:
            result = f5c.get_vip_availability(f5_ltm_username,
                                              f5_ltm_password,
                                              hostgroup,
                                              play_path,
                                              private_data_dir,
                                              validate_certs=validate_certs)

        if collector == &#39;vip_destinations&#39;:
            result = f5c.get_vip_destinations(database_full_path)

        if collector == &#39;vlans&#39;:
            result = f5c.get_vlans(f5_ltm_username,
                                   f5_ltm_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir,
                                   validate_certs=validate_certs)

        if collector == &#39;vlan_database&#39;:
            result = f5c.f5_get_vlan_db(f5_ltm_username,
                                        f5_ltm_password,
                                        hostgroup,
                                        play_path,
                                        private_data_dir,
                                        validate_certs=validate_certs)

    if collector == &#39;bgp_neighbors&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.bgp_neighbors(ios_devices_username,
                                       ios_devices_password,
                                       hostgroup,
                                       play_path,
                                       private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.bgp_neighbors(palo_alto_username,
                                       palo_alto_password,
                                       hostgroup,
                                       netmanage_path,
                                       private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_bgp_neighbors(nxos_devices_username,
                                                nxos_devices_password,
                                                hostgroup,
                                                netmanage_path,
                                                play_path,
                                                private_data_dir)

    if collector == &#39;devices_inventory&#39;:
        if ansible_os == &#39;cisco.dnac&#39;:
            result = dnc.devices_inventory(dnac_url,
                                           dnac_username,
                                           dnac_password,
                                           platform_ids=dnac_platform_ids,
                                           verify=validate_certs)

    # This needs to be implemented differently, because asyncio.run does not
    # work when run inside iPython (including Jupyter).
    # if collector == &#39;device_cdp_lldp_neighbors&#39;:
    #     if ansible_os == &#39;meraki&#39;:
    #         result = asyncio.run(
    #             mc.meraki_get_device_cdp_lldp_neighbors(meraki_api_key,
    #                                                     database_full_path,
    #                                                     meraki_serials))

    if collector == &#39;devices_modules&#39;:
        if ansible_os == &#39;cisco.dnac&#39;:
            result = dnc.devices_modules(dnac_url,
                                         dnac_username,
                                         dnac_password,
                                         platform_ids=dnac_platform_ids,
                                         verify=validate_certs)

    if collector == &#39;cam_table&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_cam_table(ios_devices_username,
                                           ios_devices_password,
                                           hostgroup,
                                           netmanage_path,
                                           play_path,
                                           private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_cam_table(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            netmanage_path,
                                            play_path,
                                            private_data_dir)

    if collector == &#39;config&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.get_config(ios_devices_username,
                                    ios_devices_password,
                                    hostgroup,
                                    play_path,
                                    private_data_dir)

    if collector == &#39;arp_table&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_arp_table(ios_devices_username,
                                           ios_devices_password,
                                           hostgroup,
                                           netmanage_path,
                                           play_path,
                                           private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_arp_table(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            netmanage_path,
                                            play_path,
                                            private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_arp_table(palo_alto_username,
                                       palo_alto_password,
                                       hostgroup,
                                       netmanage_path,
                                       private_data_dir)

    if collector == &#39;bgp_neighbors&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_bgp_neighbors(nxos_devices_username,
                                                nxos_devices_password,
                                                hostgroup,
                                                netmanage_path,
                                                play_path,
                                                private_data_dir)

    if collector == &#39;hardware_inventory&#39;:
        if ansible_os == &#39;cisco.asa.asa&#39;:
            result = cac.inventory(asa_devices_username,
                                   asa_devices_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir)

        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.inventory(ios_devices_username,
                                   ios_devices_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_inventory(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            play_path,
                                            private_data_dir)

        if ansible_os == &#39;bigip&#39;:
            result = f5c.inventory(f5_ltm_username,
                                   f5_ltm_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir,
                                   validate_certs=validate_certs)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.inventory(palo_alto_username,
                                   palo_alto_password,
                                   hostgroup,
                                   netmanage_path,
                                   private_data_dir)

    if collector == &#39;fexes_table&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_fexes_table(nxos_devices_username,
                                              nxos_devices_password,
                                              hostgroup,
                                              netmanage_path,
                                              play_path,
                                              private_data_dir)

    if collector == &#39;interface_description&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_interface_descriptions(ios_devices_username,
                                                        ios_devices_password,
                                                        hostgroup,
                                                        play_path,
                                                        private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_descriptions(nxos_devices_username,
                                                         nxos_devices_password,
                                                         hostgroup,
                                                         play_path,
                                                         private_data_dir)

    if collector == &#39;infoblox_get_network_containers&#39;:
        result = nc.get_network_containers(infoblox_url,
                                           infoblox_username,
                                           infoblox_password,
                                           infoblox_paging,
                                           validate_certs=validate_certs)

    if collector == &#39;infoblox_get_networks&#39;:
        result = nc.get_networks(infoblox_url,
                                 infoblox_username,
                                 infoblox_password,
                                 infoblox_paging,
                                 validate_certs=validate_certs)

    if collector == &#39;infoblox_get_network_containers&#39;:
        result = nc.get_network_containers(infoblox_url,
                                           infoblox_username,
                                           infoblox_password,
                                           infoblox_paging,
                                           validate_certs=validate_certs)

    if collector == &#39;infoblox_get_networks_parent_containers&#39;:
        result = nc.get_networks_parent_containers(database_full_path)

    if collector == &#39;infoblox_get_vlan_ranges&#39;:
        result = nc.get_vlan_ranges(infoblox_url,
                                    infoblox_username,
                                    infoblox_password,
                                    infoblox_paging,
                                    validate_certs=validate_certs)

    if collector == &#39;infoblox_get_vlans&#39;:
        result = nc.get_vlans(infoblox_url,
                              infoblox_username,
                              infoblox_password,
                              infoblox_paging,
                              validate_certs=validate_certs)

    if collector == &#39;interface_ip_addresses&#39;:
        if ansible_os == &#39;cisco.asa.asa&#39;:
            result = cac.get_interface_ips(asa_devices_username,
                                           asa_devices_password,
                                           hostgroup,
                                           play_path,
                                           private_data_dir)

        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_interface_ips(ios_devices_username,
                                               ios_devices_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_ips(nxos_devices_username,
                                                nxos_devices_password,
                                                hostgroup,
                                                play_path,
                                                private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_interface_ips(palo_alto_username,
                                           palo_alto_password,
                                           hostgroup,
                                           netmanage_path,
                                           private_data_dir)

    if collector == &#39;interface_status&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_status(nxos_devices_username,
                                                   nxos_devices_password,
                                                   hostgroup,
                                                   play_path,
                                                   private_data_dir)

    if collector == &#39;interface_summary&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_summary(database_full_path)

    if collector == &#39;find_uplink_by_ip&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_find_uplink_by_ip(ios_devices_username,
                                               ios_devices_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir)

    if collector == &#39;network_appliance_vlans&#39;:
        if ansible_os == &#39;meraki&#39;:
            mc.get_network_appliance_vlans(ansible_os,
                                           meraki_api_key,
                                           collector,
                                           database_full_path,
                                           timestamp,
                                           networks=meraki_networks,
                                           orgs=meraki_organizations)

    # This needs to be implemented differently, because asyncio.run does not
    # work when run inside iPython (including Jupyter).
    # if collector == &#39;network_clients&#39;:
    #     if ansible_os == &#39;meraki&#39;:
    #         result = asyncio.run(
    #             mc.meraki_get_network_clients(meraki_api_key,
    #                                           networks=meraki_networks,
    #                                           macs=meraki_macs,
    #                                           orgs=meraki_organizations,
    #                                           per_page=meraki_per_page,
    #                                           timespan=meraki_lookback,
    #                                           total_pages=meraki_tp))

    if collector == &#39;network_devices&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_network_devices(meraki_api_key,
                                                   database_full_path,
                                                   networks=meraki_networks,
                                                   orgs=meraki_organizations)

    if collector == &#39;network_device_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_network_device_statuses(
                database_full_path, meraki_networks)

    if collector == &#39;organizations&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_organizations(meraki_api_key)

    if collector == &#39;org_devices&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_org_devices(meraki_api_key,
                                               database_full_path,
                                               orgs=meraki_organizations)

    if collector == &#39;org_device_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result, idx_cols = mc.meraki_get_org_device_statuses(
                meraki_api_key,
                database_full_path,
                orgs=meraki_organizations,
                total_pages=meraki_tp
            )

    if collector == &#39;org_networks&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_org_networks(meraki_api_key,
                                                database_full_path,
                                                orgs=meraki_organizations,
                                                use_db=True)

    if collector == &#39;ospf_neighbors&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ospf_neighbors(ios_devices_username,
                                        ios_devices_password,
                                        hostgroup,
                                        play_path,
                                        private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.ospf_neighbors(palo_alto_username,
                                        palo_alto_password,
                                        hostgroup,
                                        netmanage_path,
                                        private_data_dir)

    if collector == &#39;switch_lldp_neighbors&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_switch_lldp_neighbors(database_full_path)

    if collector == &#39;switch_port_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_switch_port_statuses(meraki_api_key,
                                                        database_full_path,
                                                        meraki_networks)

    if collector == &#39;switch_port_usages&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_switch_port_usages(meraki_api_key,
                                                      database_full_path,
                                                      meraki_networks,
                                                      timestamp)

    if collector == &#39;security_rules&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_security_rules(palo_alto_username,
                                            palo_alto_password,
                                            hostgroup,
                                            play_path,
                                            private_data_dir)

    if collector == &#39;netbox_get_ipam_prefixes&#39;:
        result = nbc.netbox_get_ipam_prefixes(netbox_url, netbox_token)

    if collector == &#39;ncm_serial_numbers&#39;:
        result = swc.get_ncm_serial_numbers(npm_server,
                                            npm_username,
                                            npm_password)

    if collector == &#39;npm_containers&#39;:
        result = swc.get_npm_containers(npm_server, npm_username, npm_password)

    if collector == &#39;npm_group_members&#39;:
        result = swc.get_npm_group_members(npm_server,
                                           npm_username,
                                           npm_password,
                                           npm_group_name)

    if collector == &#39;npm_group_names&#39;:
        result = swc.get_npm_group_names(npm_server,
                                         npm_username,
                                         npm_password)

    if collector == &#39;npm_node_ids&#39;:
        result = swc.get_npm_node_ids(npm_server, npm_username, npm_password)

    if collector == &#39;npm_node_ips&#39;:
        result = swc.get_npm_node_ips(npm_server, npm_username, npm_password)

    if collector == &#39;npm_node_machine_types&#39;:
        result = swc.get_npm_node_machine_types(npm_server,
                                                npm_username,
                                                npm_password)

    if collector == &#39;npm_node_os_versions&#39;:
        result = swc.get_npm_node_os_versions(npm_server,
                                              npm_username,
                                              npm_password)

    if collector == &#39;npm_node_vendors&#39;:
        result = swc.get_npm_node_vendors(npm_server,
                                          npm_username,
                                          npm_password)

    if collector == &#39;npm_nodes&#39;:
        result = swc.get_npm_nodes(npm_server, npm_username, npm_password)

    if collector == &#39;all_interfaces&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_all_interfaces(palo_alto_username,
                                            palo_alto_password,
                                            hostgroup,
                                            netmanage_path,
                                            private_data_dir)

    if collector == &#39;logical_interfaces&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_logical_interfaces(palo_alto_username,
                                                palo_alto_password,
                                                hostgroup,
                                                netmanage_path,
                                                private_data_dir)

    if collector == &#39;physical_interfaces&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_physical_interfaces(palo_alto_username,
                                                 palo_alto_password,
                                                 hostgroup,
                                                 netmanage_path,
                                                 private_data_dir)

    if collector == &#39;port_channel_data&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_port_channel_data(nxos_devices_username,
                                                    nxos_devices_password,
                                                    hostgroup,
                                                    play_path,
                                                    private_data_dir)

    if collector == &#39;appliance_uplink_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_org_appliance_uplink_statuses(
                meraki_api_key,
                database_full_path,
                meraki_organizations)

    if collector == &#39;vpc_state&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_vpc_state(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            play_path,
                                            private_data_dir)

    if collector == &#39;vlans&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_vlan_db(ios_devices_username,
                                         ios_devices_password,
                                         hostgroup,
                                         play_path,
                                         private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_vlan_db(nxos_devices_username,
                                          nxos_devices_password,
                                          hostgroup,
                                          play_path,
                                          private_data_dir)

    if collector == &#39;vrfs&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.get_vrfs(ios_devices_username,
                                  ios_devices_password,
                                  hostgroup,
                                  play_path,
                                  private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_vrfs(nxos_devices_username,
                                       nxos_devices_password,
                                       hostgroup,
                                       play_path,
                                       private_data_dir)

    # Write the result to the database
    if len(result.columns.to_list()) &gt; 0:
        table_name = f&#39;{ansible_os.split(&#34;.&#34;)[-1]}_{collector}&#39;
        add_to_db(table_name,
                  result,
                  timestamp,
                  database_full_path,
                  method=database_method,
                  idx_cols=idx_cols)

    return result


def add_to_db(table_name: str,
              result: pd.DataFrame,
              timestamp: str,
              database_path: str,
              method: str = &#39;append&#39;,
              idx_cols: List[str] = list()) -&gt; None:
    &#39;&#39;&#39;
    Adds the output of a collector to the database.

    Parameters
    ----------
    table_name : str
        The name of the table in the database to which the data will be added.
    result : DataFrame
        The output of a collector as a Pandas DataFrame.
    timestamp : str
        The timestamp for the data in YYYY-MM-DD_hhmm format.
    database_path : str
        The path to the database where the data will be stored.
    method : str, optional
        What to do if the table already exists in the database. Options are
        &#39;append&#39;, &#39;fail&#39;, &#39;replace&#39;. Defaults to &#39;append&#39;.
    idx_cols : List[str], optional
        The list of columns to use for indexing the table in the database.
        Note that this is NOT related to the dataframe index; it is for
        indexing the SQLite database table.

    Returns
    -------
    None
    &#39;&#39;&#39;
    # Set the timestamp as the index of the dataframe (this is unrelated to
    # the &#39;idx_cols&#39; arg)
    new_idx = list()
    for i in range(0, len(result)):
        new_idx.append(timestamp)

    # Display the output to the console
    result[&#39;timestamp&#39;] = new_idx
    result = result.set_index(&#39;timestamp&#39;)

    # Check if the output directory exists. If it does not, then create it.
    exists = hp.check_dir_existence(&#39;/&#39;.join(database_path.split(&#39;/&#39;)[:-1]))
    if not exists:
        hp.create_dir(&#39;/&#39;.join(database_path.split(&#39;/&#39;)[:-1]))

    # Connect to the database
    con = hp.connect_to_db(database_path)
    cur = con.cursor()

    # Get the table schema. This also checks if the table exists, because the
    # length of &#39;schema&#39; will be 0 if it hasn&#39;t been created yet.
    schema = hp.sql_get_table_schema(database_path, table_name)

    # If the table doesn&#39;t exist, create it. (Pandas will automatically create
    # the table, but doing it manually allows us to create an auto-incrementing
    # ID column))
    column_list = result.columns.to_list()
    if &#39;table_id&#39; in column_list:
        column_list.remove(&#39;table_id&#39;)
        del result[&#39;table_id&#39;]
    columns = [f&#39;&#34;{c}&#34;&#39; for c in column_list]
    if len(schema) == 0 and len(result) &gt; 0:
        fields = &#39;,\n&#39;.join(columns)
        cur.execute(f&#39;&#39;&#39;CREATE TABLE {table_name.upper()} (
                    table_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp,
                    {fields}
                    )&#39;&#39;&#39;)

    # Check if all of the columns in &#39;result&#39; are in the table schema and add
    # them if they are not. This accounts for a common scenario that happens
    # when device output is inconsistent. For example, on Cisco NXOS devices
    # this command returns different rows if the device is using Layer 3 VPC.
    # &#39;show vpc brief | begin &#34;vPC domain id&#34; | end &#34;vPC Peer-link status&#39;
    # If the collector is run against devices using Layer 2 VPC, then run again
    # on devices using Layer 3 VPC, an additional column must be added or the
    # table insertion will fail.
    #
    # This scenario is very common, and it&#39;s not always possible to
    # future-proof collectors to account for it,
    if len(schema) &gt;= 1:
        for col in column_list:
            if col not in schema[&#39;name&#39;].to_list():
                cur.execute(f&#39;ALTER TABLE {table_name} ADD COLUMN &#34;{col}&#34;&#39;)

    # from tabulate import tabulate
    # print(tabulate(result, headers=&#39;keys&#39;, tablefmt=&#39;psql&#39;))

    # Add the dataframe to the database
    table = table_name.upper()
    result.to_sql(table, con, if_exists=method)

    # Create the SQL table index, if applicable
    if idx_cols:
        idx_name = f&#39;idx_{table_name.lower()}&#39;
        try:
            cur.execute(f&#39;&#39;&#39;CREATE INDEX {idx_name}
                            ON {table_name.upper()} ({&#39;,&#39;.join(idx_cols)})
                        &#39;&#39;&#39;)
        except Exception as e:
            print(f&#39;Caught Exception: {str(e)}&#39;)

    con.commit()
    con.close()


def create_parser() -&gt; argparse.Namespace:
    &#39;&#39;&#39;
    Create command line arguments.

    Args:
        None

    Returns:
        args:   Parsed command line arguments (argparse.Namespace)
    &#39;&#39;&#39;
    pass
    # Create the parser for command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;-d&#39;, &#39;--database&#39;,
                        help=&#39;&#39;&#39;The database name. Defaults to
                                YYYY-MM-DD.db.&#39;&#39;&#39;,
                        default=f&#39;{str(dt.datetime.now()).split()[0]}.db&#39;,
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-o&#39;, &#39;--out_dir&#39;,
                        help=&#39;&#39;&#39;The directory to save output to (the filename
                                will be auto-generated). The database will also
                                be saved here.&#39;&#39;&#39;,
                        default=os.path.expanduser(&#39;~/output&#39;),
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-u&#39;, &#39;--username&#39;,
                        help=&#39;&#39;&#39;The username for connecting to the devices. If
                                missing, script will prompt for it.&#39;&#39;&#39;,
                        default=str(),
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-P&#39;, &#39;--password&#39;,
                        help=&#39;&#39;&#39;The password for connecting to the devices.
                                This is included for external automation, but I
                                do not recommend using it when running the
                                script manually. If you do, then your password
                                could show up in the command history.&#39;&#39;&#39;,
                        default=str(),
                        action=&#39;store&#39;
                        )
    # requiredNamed = parser.add_argument_group(&#39;required named arguments&#39;)
    parser.add_argument(&#39;-c&#39;, &#39;--collectors&#39;,
                        help=&#39;&#39;&#39;A comma-delimited list of collectors to
                                run.&#39;&#39;&#39;,
                        required=True,
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-H&#39;, &#39;--hostgroups&#39;,
                        help=&#39;A comma-delimited list of hostgroups&#39;,
                        default=str(),
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-n&#39;, &#39;--netmanage_path&#39;,
                        help=&#39;The path to the Net-Manage repository&#39;,
                        required=True,
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-p&#39;, &#39;--private_data_dir&#39;,
                        help=&#39;&#39;&#39;The path to the Ansible private data
                                directory (I.e., the directory
                                containing the &#39;inventory&#39; and &#39;env&#39;
                                folders).&#39;&#39;&#39;,
                        required=True,
                        action=&#39;store&#39;
                        )
    args = parser.parse_args()
    return args


def arg_parser(args: argparse.Namespace) -&gt; tuple:
    &#39;&#39;&#39;
    Extract system args and assign variable names.

    Parameters
    ----------
    args : argparse.Namespace
        Parsed command line arguments.

    Returns
    -------
    tuple
        A tuple containing:
        - collectors: List of collectors
        - db: Database path
        - hostgroups: List of hostgroups
        - netmanage_path: Path for netmanage
        - out_dir: Output directory path
        - username: Username for authentication
        - password: Password for authentication
        - private_data_dir: Private data directory path
    &#39;&#39;&#39;
    # Set the collectors
    collectors = [c.strip() for c in args.collectors.split(&#39;,&#39;)]

    # Set the hostgroups
    hostgroups = [h.strip() for h in args.hostgroups.split(&#39;,&#39;)]

    # Set the netmanage_path, out_dir and private_data_dir
    netmanage_path = os.path.expanduser(args.netmanage_path)
    out_dir = os.path.expanduser(args.out_dir)
    private_data_dir = os.path.expanduser(args.private_data_dir)

    # Set the user credentials
    # TODO: Add support for using different credentials for each device or
    #       hostgroup. That is a common scenario.
    if args.username:
        username = args.username
    else:
        username = hp.get_username()
    if args.password:
        password = args.password
    else:
        password = hp.get_password()

    # Set the database path
    db = f&#39;{out_dir}/{args.database}&#39;

    return (
        collectors,
        db,
        hostgroups,
        netmanage_path,
        out_dir,
        username,
        password,
        private_data_dir,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="run_collectors.add_to_db"><code class="name flex">
<span>def <span class="ident">add_to_db</span></span>(<span>table_name: str, result: pandas.core.frame.DataFrame, timestamp: str, database_path: str, method: str = 'append', idx_cols: List[str] = []) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the output of a collector to the database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the table in the database to which the data will be added.</dd>
<dt><strong><code>result</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The output of a collector as a Pandas DataFrame.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>str</code></dt>
<dd>The timestamp for the data in YYYY-MM-DD_hhmm format.</dd>
<dt><strong><code>database_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database where the data will be stored.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>What to do if the table already exists in the database. Options are
'append', 'fail', 'replace'. Defaults to 'append'.</dd>
<dt><strong><code>idx_cols</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>The list of columns to use for indexing the table in the database.
Note that this is NOT related to the dataframe index; it is for
indexing the SQLite database table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_db(table_name: str,
              result: pd.DataFrame,
              timestamp: str,
              database_path: str,
              method: str = &#39;append&#39;,
              idx_cols: List[str] = list()) -&gt; None:
    &#39;&#39;&#39;
    Adds the output of a collector to the database.

    Parameters
    ----------
    table_name : str
        The name of the table in the database to which the data will be added.
    result : DataFrame
        The output of a collector as a Pandas DataFrame.
    timestamp : str
        The timestamp for the data in YYYY-MM-DD_hhmm format.
    database_path : str
        The path to the database where the data will be stored.
    method : str, optional
        What to do if the table already exists in the database. Options are
        &#39;append&#39;, &#39;fail&#39;, &#39;replace&#39;. Defaults to &#39;append&#39;.
    idx_cols : List[str], optional
        The list of columns to use for indexing the table in the database.
        Note that this is NOT related to the dataframe index; it is for
        indexing the SQLite database table.

    Returns
    -------
    None
    &#39;&#39;&#39;
    # Set the timestamp as the index of the dataframe (this is unrelated to
    # the &#39;idx_cols&#39; arg)
    new_idx = list()
    for i in range(0, len(result)):
        new_idx.append(timestamp)

    # Display the output to the console
    result[&#39;timestamp&#39;] = new_idx
    result = result.set_index(&#39;timestamp&#39;)

    # Check if the output directory exists. If it does not, then create it.
    exists = hp.check_dir_existence(&#39;/&#39;.join(database_path.split(&#39;/&#39;)[:-1]))
    if not exists:
        hp.create_dir(&#39;/&#39;.join(database_path.split(&#39;/&#39;)[:-1]))

    # Connect to the database
    con = hp.connect_to_db(database_path)
    cur = con.cursor()

    # Get the table schema. This also checks if the table exists, because the
    # length of &#39;schema&#39; will be 0 if it hasn&#39;t been created yet.
    schema = hp.sql_get_table_schema(database_path, table_name)

    # If the table doesn&#39;t exist, create it. (Pandas will automatically create
    # the table, but doing it manually allows us to create an auto-incrementing
    # ID column))
    column_list = result.columns.to_list()
    if &#39;table_id&#39; in column_list:
        column_list.remove(&#39;table_id&#39;)
        del result[&#39;table_id&#39;]
    columns = [f&#39;&#34;{c}&#34;&#39; for c in column_list]
    if len(schema) == 0 and len(result) &gt; 0:
        fields = &#39;,\n&#39;.join(columns)
        cur.execute(f&#39;&#39;&#39;CREATE TABLE {table_name.upper()} (
                    table_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp,
                    {fields}
                    )&#39;&#39;&#39;)

    # Check if all of the columns in &#39;result&#39; are in the table schema and add
    # them if they are not. This accounts for a common scenario that happens
    # when device output is inconsistent. For example, on Cisco NXOS devices
    # this command returns different rows if the device is using Layer 3 VPC.
    # &#39;show vpc brief | begin &#34;vPC domain id&#34; | end &#34;vPC Peer-link status&#39;
    # If the collector is run against devices using Layer 2 VPC, then run again
    # on devices using Layer 3 VPC, an additional column must be added or the
    # table insertion will fail.
    #
    # This scenario is very common, and it&#39;s not always possible to
    # future-proof collectors to account for it,
    if len(schema) &gt;= 1:
        for col in column_list:
            if col not in schema[&#39;name&#39;].to_list():
                cur.execute(f&#39;ALTER TABLE {table_name} ADD COLUMN &#34;{col}&#34;&#39;)

    # from tabulate import tabulate
    # print(tabulate(result, headers=&#39;keys&#39;, tablefmt=&#39;psql&#39;))

    # Add the dataframe to the database
    table = table_name.upper()
    result.to_sql(table, con, if_exists=method)

    # Create the SQL table index, if applicable
    if idx_cols:
        idx_name = f&#39;idx_{table_name.lower()}&#39;
        try:
            cur.execute(f&#39;&#39;&#39;CREATE INDEX {idx_name}
                            ON {table_name.upper()} ({&#39;,&#39;.join(idx_cols)})
                        &#39;&#39;&#39;)
        except Exception as e:
            print(f&#39;Caught Exception: {str(e)}&#39;)

    con.commit()
    con.close()</code></pre>
</details>
</dd>
<dt id="run_collectors.arg_parser"><code class="name flex">
<span>def <span class="ident">arg_parser</span></span>(<span>args: argparse.Namespace) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Extract system args and assign variable names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>argparse.Namespace</code></dt>
<dd>Parsed command line arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing:
- collectors: List of collectors
- db: Database path
- hostgroups: List of hostgroups
- netmanage_path: Path for netmanage
- out_dir: Output directory path
- username: Username for authentication
- password: Password for authentication
- private_data_dir: Private data directory path</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arg_parser(args: argparse.Namespace) -&gt; tuple:
    &#39;&#39;&#39;
    Extract system args and assign variable names.

    Parameters
    ----------
    args : argparse.Namespace
        Parsed command line arguments.

    Returns
    -------
    tuple
        A tuple containing:
        - collectors: List of collectors
        - db: Database path
        - hostgroups: List of hostgroups
        - netmanage_path: Path for netmanage
        - out_dir: Output directory path
        - username: Username for authentication
        - password: Password for authentication
        - private_data_dir: Private data directory path
    &#39;&#39;&#39;
    # Set the collectors
    collectors = [c.strip() for c in args.collectors.split(&#39;,&#39;)]

    # Set the hostgroups
    hostgroups = [h.strip() for h in args.hostgroups.split(&#39;,&#39;)]

    # Set the netmanage_path, out_dir and private_data_dir
    netmanage_path = os.path.expanduser(args.netmanage_path)
    out_dir = os.path.expanduser(args.out_dir)
    private_data_dir = os.path.expanduser(args.private_data_dir)

    # Set the user credentials
    # TODO: Add support for using different credentials for each device or
    #       hostgroup. That is a common scenario.
    if args.username:
        username = args.username
    else:
        username = hp.get_username()
    if args.password:
        password = args.password
    else:
        password = hp.get_password()

    # Set the database path
    db = f&#39;{out_dir}/{args.database}&#39;

    return (
        collectors,
        db,
        hostgroups,
        netmanage_path,
        out_dir,
        username,
        password,
        private_data_dir,
    )</code></pre>
</details>
</dd>
<dt id="run_collectors.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>ansible_os: str, collector: str, hostgroup: str, timestamp: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>This function calls the test that the user requested.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ansible_os</code></strong> :&ensp;<code>str</code></dt>
<dd>The Ansible OS of the hostgroup.</dd>
<dt><strong><code>collector</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the collector that the user requested.</dd>
<dt><strong><code>hostgroup</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the Ansible hostgroup.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>str</code></dt>
<dd>The timestamp is YYYY-MM-DD_hhmm format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the data from the collector.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(ansible_os: str,
            collector: str,
            hostgroup: str,
            timestamp: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    This function calls the test that the user requested.

    Parameters
    ----------
    ansible_os : str
        The Ansible OS of the hostgroup.
    collector : str
        The name of the collector that the user requested.
    hostgroup : str
        The name of the Ansible hostgroup.
    timestamp : str
        The timestamp is YYYY-MM-DD_hhmm format.

    Returns
    -------
    result : pd.DataFrame
        A DataFrame containing the data from the collector.
    &#39;&#39;&#39;
    # Read global variables
    database_name = os.environ[&#39;database_name&#39;]
    database_path = os.path.expanduser(os.environ[&#39;database_path&#39;])
    netmanage_path = os.path.expanduser(
        os.environ[&#39;netmanage_path&#39;].rstrip(&#39;/&#39;))
    private_data_dir = os.path.expanduser(
        os.environ[&#39;private_data_directory&#39;])
    validate_certs = ast.literal_eval(os.environ[&#39;validate_certs&#39;])
    database_method = os.environ[&#39;database_method&#39;]

    # Read Cisco ASA variables
    asa_devices_username = os.environ[&#39;asa_devices_username&#39;]
    asa_devices_password = os.environ[&#39;asa_devices_password&#39;]

    # Read Cisco DNAC variables
    dnac_url = os.environ[&#39;dnac_url&#39;]
    dnac_username = os.environ[&#39;dnac_username&#39;]
    dnac_password = os.environ[&#39;dnac_password&#39;]
    dnac_platform_ids = list(
        filter(None, os.environ[&#39;dnac_platform_ids&#39;].split(&#39;,&#39;)))

    # Read Cisco IOS variables
    ios_devices_username = os.environ[&#39;ios_devices_username&#39;]
    ios_devices_password = os.environ[&#39;ios_devices_password&#39;]

    # Read Cisco NXOS variables
    nxos_devices_username = os.environ[&#39;nxos_devices_username&#39;]
    nxos_devices_password = os.environ[&#39;nxos_devices_password&#39;]

    # Read F5 LTM variables
    f5_ltm_username = os.environ[&#39;f5_ltm_username&#39;]
    f5_ltm_password = os.environ[&#39;f5_ltm_password&#39;]
    # f5_log_range = os.environ[&#39;f5_log_range&#39;]
    # f5_log_type = os.environ[&#39;f5_log_type&#39;]
    # f5_num_lines = os.environ[&#39;f5_num_lines&#39;]

    # Read Infoblox variables
    infoblox_url = os.environ[&#39;infoblox_url&#39;]
    infoblox_username = os.environ[&#39;infoblox_username&#39;]
    infoblox_password = os.environ[&#39;infoblox_password&#39;]
    infoblox_paging = os.environ[&#39;infoblox_paging&#39;]

    # Read Meraki variables
    meraki_api_key = os.environ[&#39;meraki_api_key&#39;]
    meraki_networks = list(filter(
        None, os.environ[&#39;meraki_networks&#39;].split(&#39;,&#39;)))
    meraki_organizations = list(filter(
        None, os.environ[&#39;meraki_organizations&#39;].split(&#39;,&#39;)))
    meraki_serials = list(filter(
        None, os.environ[&#39;meraki_serials&#39;].split(&#39;,&#39;)))
    meraki_serials = [_.strip() for _ in meraki_serials]
    try:
        meraki_tp = int(os.environ[&#39;meraki_total_pages&#39;])
    except ValueError:
        meraki_tp = -1
    # These 3 variables are temporarily commented out until we re-enable the
    # asyncio collectors.
    # meraki_macs = os.environ[&#39;meraki_macs&#39;]
    # meraki_lookback = os.environ[&#39;meraki_lookback_timespan&#39;]
    # meraki_per_page = os.environ[&#39;meraki_per_page&#39;]

    # Read Netbox variables
    netbox_url = os.environ[&#39;netbox_url&#39;]
    netbox_token = os.environ[&#39;netbox_token&#39;]

    # Read Palo Alto variables
    palo_alto_username = os.environ[&#39;palo_alto_username&#39;]
    palo_alto_password = os.environ[&#39;palo_alto_password&#39;]

    # Read Solarwinds NPM variables
    npm_server = os.environ[&#39;solarwinds_npm_server&#39;]
    npm_username = os.environ[&#39;solarwinds_npm_username&#39;]
    npm_password = os.environ[&#39;solarwinds_npm_password&#39;]
    npm_group_name = os.environ[&#39;solarwinds_npm_group_name&#39;]

    # Create the output folder if it does not already exist.
    exists = hp.check_dir_existence(database_path)
    if not exists:
        hp.create_dir(database_path)

    # Define additional variables
    database_full_path = f&#39;{database_path}/{database_name}&#39;
    idx_cols = list()
    play_path = netmanage_path + &#39;/playbooks&#39;

    # Create an empty DataFrame for when collectors return no results.
    result = pd.DataFrame()

    # Call collector and return results.
    if ansible_os == &#39;bigip&#39;:
        if collector == &#39;arp_table&#39;:
            result = f5c.get_arp_table(f5_ltm_username,
                                       f5_ltm_password,
                                       hostgroup,
                                       netmanage_path,
                                       play_path,
                                       private_data_dir,
                                       validate_certs=validate_certs)

        if collector == &#39;interface_description&#39;:
            result = f5c.\
                get_interface_descriptions(f5_ltm_username,
                                           f5_ltm_password,
                                           hostgroup,
                                           netmanage_path,
                                           play_path,
                                           private_data_dir,
                                           reverse_dns=False,
                                           validate_certs=validate_certs)

        if collector == &#39;interface_summary&#39;:
            result = f5c.get_interface_status(f5_ltm_username,
                                              f5_ltm_password,
                                              hostgroup,
                                              play_path,
                                              private_data_dir,
                                              validate_certs=validate_certs)

        # Do not uncomment the &#39;logs&#39; collector until it is updated to use
        # bash. This is because of a suspected F5 bug that causes the active
        # unit to sometimes hang when retrieving the logs with a tmsh command
        # (Ansible) or a REST API call.

        # if collector == &#39;logs&#39;:
        #     result = f5c.get_log_files(f5_ltm_username,
        #                                f5_ltm_password,
        #                                hostgroup,
        #                                play_path,
        #                                private_data_dir,
        #                                log_type=f5_log_type,
        #                                log_range=f5_log_range,
        #                                num_lines=f5_num_lines,
        #                                validate_certs=validate_certs)

        if collector == &#39;node_availability&#39;:
            result = f5c.get_node_availability(f5_ltm_username,
                                               f5_ltm_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir,
                                               validate_certs=validate_certs)

        if collector == &#39;pool_availability&#39;:
            result = f5c.get_pool_availability(f5_ltm_username,
                                               f5_ltm_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir,
                                               validate_certs=validate_certs)

        if collector == &#39;pool_summary&#39;:
            result = f5c.get_pool_data(f5_ltm_username,
                                       f5_ltm_password,
                                       hostgroup,
                                       play_path,
                                       private_data_dir,
                                       validate_certs=validate_certs)

        if collector == &#39;pool_member_availability&#39;:
            result = f5c.\
                get_pool_member_availability(f5_ltm_username,
                                             f5_ltm_password,
                                             hostgroup,
                                             play_path,
                                             private_data_dir,
                                             validate_certs=validate_certs)

        if collector == &#39;self_ips&#39;:
            result = f5c.get_self_ips(f5_ltm_username,
                                      f5_ltm_password,
                                      hostgroup,
                                      play_path,
                                      private_data_dir,
                                      validate_certs=validate_certs)

        if collector == &#39;vip_availability&#39;:
            result = f5c.get_vip_availability(f5_ltm_username,
                                              f5_ltm_password,
                                              hostgroup,
                                              play_path,
                                              private_data_dir,
                                              validate_certs=validate_certs)

        if collector == &#39;vip_destinations&#39;:
            result = f5c.get_vip_destinations(database_full_path)

        if collector == &#39;vlans&#39;:
            result = f5c.get_vlans(f5_ltm_username,
                                   f5_ltm_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir,
                                   validate_certs=validate_certs)

        if collector == &#39;vlan_database&#39;:
            result = f5c.f5_get_vlan_db(f5_ltm_username,
                                        f5_ltm_password,
                                        hostgroup,
                                        play_path,
                                        private_data_dir,
                                        validate_certs=validate_certs)

    if collector == &#39;bgp_neighbors&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.bgp_neighbors(ios_devices_username,
                                       ios_devices_password,
                                       hostgroup,
                                       play_path,
                                       private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.bgp_neighbors(palo_alto_username,
                                       palo_alto_password,
                                       hostgroup,
                                       netmanage_path,
                                       private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_bgp_neighbors(nxos_devices_username,
                                                nxos_devices_password,
                                                hostgroup,
                                                netmanage_path,
                                                play_path,
                                                private_data_dir)

    if collector == &#39;devices_inventory&#39;:
        if ansible_os == &#39;cisco.dnac&#39;:
            result = dnc.devices_inventory(dnac_url,
                                           dnac_username,
                                           dnac_password,
                                           platform_ids=dnac_platform_ids,
                                           verify=validate_certs)

    # This needs to be implemented differently, because asyncio.run does not
    # work when run inside iPython (including Jupyter).
    # if collector == &#39;device_cdp_lldp_neighbors&#39;:
    #     if ansible_os == &#39;meraki&#39;:
    #         result = asyncio.run(
    #             mc.meraki_get_device_cdp_lldp_neighbors(meraki_api_key,
    #                                                     database_full_path,
    #                                                     meraki_serials))

    if collector == &#39;devices_modules&#39;:
        if ansible_os == &#39;cisco.dnac&#39;:
            result = dnc.devices_modules(dnac_url,
                                         dnac_username,
                                         dnac_password,
                                         platform_ids=dnac_platform_ids,
                                         verify=validate_certs)

    if collector == &#39;cam_table&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_cam_table(ios_devices_username,
                                           ios_devices_password,
                                           hostgroup,
                                           netmanage_path,
                                           play_path,
                                           private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_cam_table(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            netmanage_path,
                                            play_path,
                                            private_data_dir)

    if collector == &#39;config&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.get_config(ios_devices_username,
                                    ios_devices_password,
                                    hostgroup,
                                    play_path,
                                    private_data_dir)

    if collector == &#39;arp_table&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_arp_table(ios_devices_username,
                                           ios_devices_password,
                                           hostgroup,
                                           netmanage_path,
                                           play_path,
                                           private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_arp_table(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            netmanage_path,
                                            play_path,
                                            private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_arp_table(palo_alto_username,
                                       palo_alto_password,
                                       hostgroup,
                                       netmanage_path,
                                       private_data_dir)

    if collector == &#39;bgp_neighbors&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_bgp_neighbors(nxos_devices_username,
                                                nxos_devices_password,
                                                hostgroup,
                                                netmanage_path,
                                                play_path,
                                                private_data_dir)

    if collector == &#39;hardware_inventory&#39;:
        if ansible_os == &#39;cisco.asa.asa&#39;:
            result = cac.inventory(asa_devices_username,
                                   asa_devices_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir)

        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.inventory(ios_devices_username,
                                   ios_devices_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_inventory(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            play_path,
                                            private_data_dir)

        if ansible_os == &#39;bigip&#39;:
            result = f5c.inventory(f5_ltm_username,
                                   f5_ltm_password,
                                   hostgroup,
                                   play_path,
                                   private_data_dir,
                                   validate_certs=validate_certs)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.inventory(palo_alto_username,
                                   palo_alto_password,
                                   hostgroup,
                                   netmanage_path,
                                   private_data_dir)

    if collector == &#39;fexes_table&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_fexes_table(nxos_devices_username,
                                              nxos_devices_password,
                                              hostgroup,
                                              netmanage_path,
                                              play_path,
                                              private_data_dir)

    if collector == &#39;interface_description&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_interface_descriptions(ios_devices_username,
                                                        ios_devices_password,
                                                        hostgroup,
                                                        play_path,
                                                        private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_descriptions(nxos_devices_username,
                                                         nxos_devices_password,
                                                         hostgroup,
                                                         play_path,
                                                         private_data_dir)

    if collector == &#39;infoblox_get_network_containers&#39;:
        result = nc.get_network_containers(infoblox_url,
                                           infoblox_username,
                                           infoblox_password,
                                           infoblox_paging,
                                           validate_certs=validate_certs)

    if collector == &#39;infoblox_get_networks&#39;:
        result = nc.get_networks(infoblox_url,
                                 infoblox_username,
                                 infoblox_password,
                                 infoblox_paging,
                                 validate_certs=validate_certs)

    if collector == &#39;infoblox_get_network_containers&#39;:
        result = nc.get_network_containers(infoblox_url,
                                           infoblox_username,
                                           infoblox_password,
                                           infoblox_paging,
                                           validate_certs=validate_certs)

    if collector == &#39;infoblox_get_networks_parent_containers&#39;:
        result = nc.get_networks_parent_containers(database_full_path)

    if collector == &#39;infoblox_get_vlan_ranges&#39;:
        result = nc.get_vlan_ranges(infoblox_url,
                                    infoblox_username,
                                    infoblox_password,
                                    infoblox_paging,
                                    validate_certs=validate_certs)

    if collector == &#39;infoblox_get_vlans&#39;:
        result = nc.get_vlans(infoblox_url,
                              infoblox_username,
                              infoblox_password,
                              infoblox_paging,
                              validate_certs=validate_certs)

    if collector == &#39;interface_ip_addresses&#39;:
        if ansible_os == &#39;cisco.asa.asa&#39;:
            result = cac.get_interface_ips(asa_devices_username,
                                           asa_devices_password,
                                           hostgroup,
                                           play_path,
                                           private_data_dir)

        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_interface_ips(ios_devices_username,
                                               ios_devices_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_ips(nxos_devices_username,
                                                nxos_devices_password,
                                                hostgroup,
                                                play_path,
                                                private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_interface_ips(palo_alto_username,
                                           palo_alto_password,
                                           hostgroup,
                                           netmanage_path,
                                           private_data_dir)

    if collector == &#39;interface_status&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_status(nxos_devices_username,
                                                   nxos_devices_password,
                                                   hostgroup,
                                                   play_path,
                                                   private_data_dir)

    if collector == &#39;interface_summary&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_interface_summary(database_full_path)

    if collector == &#39;find_uplink_by_ip&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_find_uplink_by_ip(ios_devices_username,
                                               ios_devices_password,
                                               hostgroup,
                                               play_path,
                                               private_data_dir)

    if collector == &#39;network_appliance_vlans&#39;:
        if ansible_os == &#39;meraki&#39;:
            mc.get_network_appliance_vlans(ansible_os,
                                           meraki_api_key,
                                           collector,
                                           database_full_path,
                                           timestamp,
                                           networks=meraki_networks,
                                           orgs=meraki_organizations)

    # This needs to be implemented differently, because asyncio.run does not
    # work when run inside iPython (including Jupyter).
    # if collector == &#39;network_clients&#39;:
    #     if ansible_os == &#39;meraki&#39;:
    #         result = asyncio.run(
    #             mc.meraki_get_network_clients(meraki_api_key,
    #                                           networks=meraki_networks,
    #                                           macs=meraki_macs,
    #                                           orgs=meraki_organizations,
    #                                           per_page=meraki_per_page,
    #                                           timespan=meraki_lookback,
    #                                           total_pages=meraki_tp))

    if collector == &#39;network_devices&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_network_devices(meraki_api_key,
                                                   database_full_path,
                                                   networks=meraki_networks,
                                                   orgs=meraki_organizations)

    if collector == &#39;network_device_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_network_device_statuses(
                database_full_path, meraki_networks)

    if collector == &#39;organizations&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_organizations(meraki_api_key)

    if collector == &#39;org_devices&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_org_devices(meraki_api_key,
                                               database_full_path,
                                               orgs=meraki_organizations)

    if collector == &#39;org_device_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result, idx_cols = mc.meraki_get_org_device_statuses(
                meraki_api_key,
                database_full_path,
                orgs=meraki_organizations,
                total_pages=meraki_tp
            )

    if collector == &#39;org_networks&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_org_networks(meraki_api_key,
                                                database_full_path,
                                                orgs=meraki_organizations,
                                                use_db=True)

    if collector == &#39;ospf_neighbors&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ospf_neighbors(ios_devices_username,
                                        ios_devices_password,
                                        hostgroup,
                                        play_path,
                                        private_data_dir)

        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.ospf_neighbors(palo_alto_username,
                                        palo_alto_password,
                                        hostgroup,
                                        netmanage_path,
                                        private_data_dir)

    if collector == &#39;switch_lldp_neighbors&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_switch_lldp_neighbors(database_full_path)

    if collector == &#39;switch_port_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_switch_port_statuses(meraki_api_key,
                                                        database_full_path,
                                                        meraki_networks)

    if collector == &#39;switch_port_usages&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_switch_port_usages(meraki_api_key,
                                                      database_full_path,
                                                      meraki_networks,
                                                      timestamp)

    if collector == &#39;security_rules&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_security_rules(palo_alto_username,
                                            palo_alto_password,
                                            hostgroup,
                                            play_path,
                                            private_data_dir)

    if collector == &#39;netbox_get_ipam_prefixes&#39;:
        result = nbc.netbox_get_ipam_prefixes(netbox_url, netbox_token)

    if collector == &#39;ncm_serial_numbers&#39;:
        result = swc.get_ncm_serial_numbers(npm_server,
                                            npm_username,
                                            npm_password)

    if collector == &#39;npm_containers&#39;:
        result = swc.get_npm_containers(npm_server, npm_username, npm_password)

    if collector == &#39;npm_group_members&#39;:
        result = swc.get_npm_group_members(npm_server,
                                           npm_username,
                                           npm_password,
                                           npm_group_name)

    if collector == &#39;npm_group_names&#39;:
        result = swc.get_npm_group_names(npm_server,
                                         npm_username,
                                         npm_password)

    if collector == &#39;npm_node_ids&#39;:
        result = swc.get_npm_node_ids(npm_server, npm_username, npm_password)

    if collector == &#39;npm_node_ips&#39;:
        result = swc.get_npm_node_ips(npm_server, npm_username, npm_password)

    if collector == &#39;npm_node_machine_types&#39;:
        result = swc.get_npm_node_machine_types(npm_server,
                                                npm_username,
                                                npm_password)

    if collector == &#39;npm_node_os_versions&#39;:
        result = swc.get_npm_node_os_versions(npm_server,
                                              npm_username,
                                              npm_password)

    if collector == &#39;npm_node_vendors&#39;:
        result = swc.get_npm_node_vendors(npm_server,
                                          npm_username,
                                          npm_password)

    if collector == &#39;npm_nodes&#39;:
        result = swc.get_npm_nodes(npm_server, npm_username, npm_password)

    if collector == &#39;all_interfaces&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_all_interfaces(palo_alto_username,
                                            palo_alto_password,
                                            hostgroup,
                                            netmanage_path,
                                            private_data_dir)

    if collector == &#39;logical_interfaces&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_logical_interfaces(palo_alto_username,
                                                palo_alto_password,
                                                hostgroup,
                                                netmanage_path,
                                                private_data_dir)

    if collector == &#39;physical_interfaces&#39;:
        if ansible_os == &#39;paloaltonetworks.panos&#39;:
            result = pac.get_physical_interfaces(palo_alto_username,
                                                 palo_alto_password,
                                                 hostgroup,
                                                 netmanage_path,
                                                 private_data_dir)

    if collector == &#39;port_channel_data&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_port_channel_data(nxos_devices_username,
                                                    nxos_devices_password,
                                                    hostgroup,
                                                    play_path,
                                                    private_data_dir)

    if collector == &#39;appliance_uplink_statuses&#39;:
        if ansible_os == &#39;meraki&#39;:
            result = mc.meraki_get_org_appliance_uplink_statuses(
                meraki_api_key,
                database_full_path,
                meraki_organizations)

    if collector == &#39;vpc_state&#39;:
        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_vpc_state(nxos_devices_username,
                                            nxos_devices_password,
                                            hostgroup,
                                            play_path,
                                            private_data_dir)

    if collector == &#39;vlans&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.ios_get_vlan_db(ios_devices_username,
                                         ios_devices_password,
                                         hostgroup,
                                         play_path,
                                         private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_vlan_db(nxos_devices_username,
                                          nxos_devices_password,
                                          hostgroup,
                                          play_path,
                                          private_data_dir)

    if collector == &#39;vrfs&#39;:
        if ansible_os == &#39;cisco.ios.ios&#39;:
            result = cic.get_vrfs(ios_devices_username,
                                  ios_devices_password,
                                  hostgroup,
                                  play_path,
                                  private_data_dir)

        if ansible_os == &#39;cisco.nxos.nxos&#39;:
            result = cnc.nxos_get_vrfs(nxos_devices_username,
                                       nxos_devices_password,
                                       hostgroup,
                                       play_path,
                                       private_data_dir)

    # Write the result to the database
    if len(result.columns.to_list()) &gt; 0:
        table_name = f&#39;{ansible_os.split(&#34;.&#34;)[-1]}_{collector}&#39;
        add_to_db(table_name,
                  result,
                  timestamp,
                  database_full_path,
                  method=database_method,
                  idx_cols=idx_cols)

    return result</code></pre>
</details>
</dd>
<dt id="run_collectors.create_parser"><code class="name flex">
<span>def <span class="ident">create_parser</span></span>(<span>) ‑> argparse.Namespace</span>
</code></dt>
<dd>
<div class="desc"><p>Create command line arguments.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>args</code></dt>
<dd>Parsed command line arguments (argparse.Namespace)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_parser() -&gt; argparse.Namespace:
    &#39;&#39;&#39;
    Create command line arguments.

    Args:
        None

    Returns:
        args:   Parsed command line arguments (argparse.Namespace)
    &#39;&#39;&#39;
    pass
    # Create the parser for command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument(&#39;-d&#39;, &#39;--database&#39;,
                        help=&#39;&#39;&#39;The database name. Defaults to
                                YYYY-MM-DD.db.&#39;&#39;&#39;,
                        default=f&#39;{str(dt.datetime.now()).split()[0]}.db&#39;,
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-o&#39;, &#39;--out_dir&#39;,
                        help=&#39;&#39;&#39;The directory to save output to (the filename
                                will be auto-generated). The database will also
                                be saved here.&#39;&#39;&#39;,
                        default=os.path.expanduser(&#39;~/output&#39;),
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-u&#39;, &#39;--username&#39;,
                        help=&#39;&#39;&#39;The username for connecting to the devices. If
                                missing, script will prompt for it.&#39;&#39;&#39;,
                        default=str(),
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-P&#39;, &#39;--password&#39;,
                        help=&#39;&#39;&#39;The password for connecting to the devices.
                                This is included for external automation, but I
                                do not recommend using it when running the
                                script manually. If you do, then your password
                                could show up in the command history.&#39;&#39;&#39;,
                        default=str(),
                        action=&#39;store&#39;
                        )
    # requiredNamed = parser.add_argument_group(&#39;required named arguments&#39;)
    parser.add_argument(&#39;-c&#39;, &#39;--collectors&#39;,
                        help=&#39;&#39;&#39;A comma-delimited list of collectors to
                                run.&#39;&#39;&#39;,
                        required=True,
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-H&#39;, &#39;--hostgroups&#39;,
                        help=&#39;A comma-delimited list of hostgroups&#39;,
                        default=str(),
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-n&#39;, &#39;--netmanage_path&#39;,
                        help=&#39;The path to the Net-Manage repository&#39;,
                        required=True,
                        action=&#39;store&#39;
                        )
    parser.add_argument(&#39;-p&#39;, &#39;--private_data_dir&#39;,
                        help=&#39;&#39;&#39;The path to the Ansible private data
                                directory (I.e., the directory
                                containing the &#39;inventory&#39; and &#39;env&#39;
                                folders).&#39;&#39;&#39;,
                        required=True,
                        action=&#39;store&#39;
                        )
    args = parser.parse_args()
    return args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="run_collectors.add_to_db" href="#run_collectors.add_to_db">add_to_db</a></code></li>
<li><code><a title="run_collectors.arg_parser" href="#run_collectors.arg_parser">arg_parser</a></code></li>
<li><code><a title="run_collectors.collect" href="#run_collectors.collect">collect</a></code></li>
<li><code><a title="run_collectors.create_parser" href="#run_collectors.create_parser">create_parser</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>