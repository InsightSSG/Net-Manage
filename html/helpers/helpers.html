<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>helpers.helpers API documentation</title>
<meta name="description" content="A library of generic helper functions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>helpers.helpers</code></h1>
</header>
<section id="section-intro">
<p>A library of generic helper functions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#39;&#39;&#39;
A library of generic helper functions.
&#39;&#39;&#39;

import ansible_runner
import ast
import glob
import ipaddress
import numpy as np
import os
import pandas as pd
import re
import requests
import sqlite3 as sl
import sys
import time
import yaml
from datetime import datetime as dt
from getpass import getpass
from tabulate import tabulate
from typing import Any, Dict, List, Tuple, Union


def ansible_create_collectors_df(hostgroups: List[str],
                                 collectors: List[str]) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Create a DataFrame where the index is the selected collectors and each row
    contains a comma-delimited string of selected hostgroups.

    Parameters
    ----------
    hostgroups : list of str
        A list of hostgroups, each of which is a comma-delimited string.
    collectors : list of str
        A list of one or more collectors, each of which is a comma-delimited
        string.

    Returns
    -------
    df_collectors : pd.DataFrame
        A DataFrame created from hostgroups and collectors.

    Examples
    --------
    &gt;&gt;&gt; hostgroups = [&#39;hostgroup1&#39;, &#39;hostgroup2&#39;]
    &gt;&gt;&gt; collectors = [&#39;collector1&#39;, &#39;collector2&#39;]
    &gt;&gt;&gt; df_collectors = ansible_create_collectors_df(hostgroups, collectors)
    &gt;&gt;&gt; print(df_collectors)
    &#39;&#39;&#39;
    df_data = list()
    for c in collectors:
        df_data.append([c, &#39;,&#39;.join(hostgroups)])
        df_collectors = pd.DataFrame(data=df_data, columns=[&#39;collector&#39;,
                                                            &#39;hostgroups&#39;])
    df_collectors = df_collectors.set_index(&#39;collector&#39;)

    return df_collectors


def ansible_create_vars_df(hostgroups: List[str],
                           private_data_dir: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Create a DataFrame containing the Ansible variables for each hostgroup.

    This function is designed to be used with the net-manage.ipynb. It reads
    all the host groups from the &#39;df_test&#39;, gets the Ansible variables for each
    group from the host file, creates a DataFrame containing the variables,
    then returns it.

    Parameters
    ----------
    hostgroups : list of str
        A list of hostgroups.
    private_data_dir : str
        The path to the Ansible private_data_dir, which is the directory
        containing the &#39;inventory&#39; folder. The default is the current folder.

    Returns
    -------
    df_vars : pd.DataFrame
        A DataFrame containing the group variables.

    Examples
    --------
    &gt;&gt;&gt; hostgroups = [&#39;group1&#39;, &#39;group2&#39;]
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; df_vars = ansible_create_vars_df(hostgroups, private_data_dir)
    &gt;&gt;&gt; print(df_vars)
    &#39;&#39;&#39;
    host_vars = dict()

    for g in hostgroups:
        group_vars = ansible_get_host_variables(g, private_data_dir)
        host_vars[g] = group_vars

    # Create a dictionary to store the variable data for each group
    df_data = dict()
    df_data[&#39;host_group&#39;] = list()

    # Iterate through the keys for each group in &#39;host_vars&#39;, adding it as a
    # key to &#39;df_data&#39;
    for key, value in host_vars.items():
        for k in value:
            if k != &#39;ansible_user&#39; and k != &#39;ansible_password&#39;:
                df_data[k] = list()

    # Iterate through &#39;host_vars&#39;, populating &#39;df_data&#39;
    for key, value in host_vars.items():
        df_data[&#39;host_group&#39;].append(key)
        for item in df_data:
            if item != &#39;host_group&#39;:
                result = value.get(item)
                df_data[item].append(result)

    df_vars = pd.DataFrame.from_dict(df_data)

    df_vars = df_vars.set_index(&#39;host_group&#39;)

    return df_vars


def ansible_get_all_hostgroup_os(private_data_dir: str) -&gt; Dict[str, str]:
    &#39;&#39;&#39;
    Get the Ansible OS for every hostgroup.

    Parameters
    ----------
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the directory
        containing the &#39;inventory&#39; folder. The default is the current folder.

    Returns
    -------
    groups_os : dict
        The Ansible OS for all host groups. The keys are host group names and
        the values are the corresponding Ansible OS.

    Examples
    --------
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; groups_os = ansible_get_all_hostgroup_os(private_data_dir)
    &gt;&gt;&gt; print(groups_os)
    &#39;&#39;&#39;
    # Get all group variables
    groups_vars = ansible_get_all_host_variables(private_data_dir)

    groups_os = dict()

    for key, value in groups_vars.items():
        group_vars = value.get(&#39;vars&#39;)
        if group_vars and group_vars.get(&#39;ansible_network_os&#39;):
            groups_os[key] = value[&#39;vars&#39;][&#39;ansible_network_os&#39;]

    return groups_os


def ansible_get_all_host_variables(private_data_dir: str) -&gt; Dict[str, str]:
    &#39;&#39;&#39;
    Get the Ansible variables for all hostgroups in the inventory.

    Parameters
    ----------
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the directory
        containing the &#39;inventory&#39; folder. The default is the current folder.

    Returns
    -------
    groups_vars : dict
        The Ansible variables for all host groups. The keys are host group
        names and the values are the corresponding Ansible variables.

    Examples
    --------
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; groups_vars = ansible_get_all_host_variables(private_data_dir)
    &gt;&gt;&gt; print(groups_vars)
    &#39;&#39;&#39;
    # Read the contents of the playbook into a dictionary
    with open(f&#39;{private_data_dir}/inventory/hosts&#39;) as f:
        groups_vars = yaml.load(f, Loader=yaml.FullLoader)
    return groups_vars


def check_dir_existence(dir_path: str) -&gt; bool:
    &#39;&#39;&#39;
    Check whether a directory exists.

    Parameters
    ----------
    dir_path : str
        The path to the directory.

    Returns
    -------
    exists : bool
        A boolean to indicate whether the directory exists.

    Examples
    --------
    &gt;&gt;&gt; dir_path = &#39;/path/to/directory&#39;
    &gt;&gt;&gt; exists = check_dir_existence(dir_path)
    &gt;&gt;&gt; print(exists)
    &#39;&#39;&#39;
    exists = False
    if os.path.exists(dir_path):
        exists = True
    return exists


def convert_mask_to_cidr(netmask: str) -&gt; str:
    &#39;&#39;&#39;
    Convert a subnet mask to CIDR notation.

    Parameters
    ----------
    netmask : str
        A subnet mask in xxx.xxx.xxx.xxx format.

    Returns
    -------
    cidr : str
        The number of bits in the subnet mask (CIDR).

    Examples
    --------
    &gt;&gt;&gt; netmask = &#39;255.255.255.0&#39;
    &gt;&gt;&gt; cidr = convert_mask_to_cidr(netmask)
    &gt;&gt;&gt; print(cidr)
    &#39;&#39;&#39;
    cidr = sum(bin(int(x)).count(&#39;1&#39;) for x in netmask.split(&#39;.&#39;))
    return cidr


def create_dir(dir_path: str) -&gt; None:
    &#39;&#39;&#39;
    Create a directory.

    Parameters
    ----------
    dir_path : str
        The path to the directory.

    Returns
    -------
    None

    Examples
    --------
    &gt;&gt;&gt; dir_path = &#39;/path/to/new/directory&#39;
    &gt;&gt;&gt; create_dir(dir_path)
    &#39;&#39;&#39;
    os.mkdir(dir_path)


def define_supported_validation_tables() -&gt; List[str]:
    &#39;&#39;&#39;
    Return a list of tables that are supported for validation.

    Returns
    -------
    supported_tables : list
        A list of supported tables.

    Examples
    --------
    &gt;&gt;&gt; supported_tables = define_supported_validation_tables()
    &gt;&gt;&gt; print(supported_tables)
    &#39;&#39;&#39;
    supported_tables = dict()

    supported_tables[&#39;MERAKI_ORG_DEVICE_STATUSES&#39;] = dict()
    supported_tables[&#39;MERAKI_ORG_DEVICE_STATUSES&#39;][&#39;status&#39;] = &#39;online&#39;

    supported_tables[&#39;BIGIP_POOL_AVAILABILITY&#39;] = dict()
    supported_tables[&#39;BIGIP_POOL_AVAILABILITY&#39;][&#39;availability&#39;] = &#39;available&#39;

    supported_tables[&#39;BIGIP_POOL_MEMBER_AVAILABILITY&#39;] = dict()
    supported_tables[&#39;BIGIP_POOL_MEMBER_AVAILABILITY&#39;][&#39;pool_member_state&#39;] = \
        &#39;available&#39;

    supported_tables[&#39;BIGIP_VIP_AVAILABILITY&#39;] = dict()
    supported_tables[&#39;BIGIP_VIP_AVAILABILITY&#39;][&#39;availability&#39;] = &#39;available&#39;

    return supported_tables


def get_database_tables(db_path: str) -&gt; List[str]:
    &#39;&#39;&#39;
    Get all of the tables out of the database.

    Parameters
    ----------
    db_path : str
        The path to the database.

    Returns
    -------
    tables : list
        A list of tables.

    Examples
    --------
    &gt;&gt;&gt; db_path = &#39;/path/to/database&#39;
    &gt;&gt;&gt; tables = get_database_tables(db_path)
    &gt;&gt;&gt; print(tables)
    &#39;&#39;&#39;
    # sqlite_schema used to be named sqlite_master. This method tries the new
    # name but will fail back to the old name if the user is on an older
    # version
    name_old = &#39;master&#39;
    name_new = &#39;schema&#39;
    con = connect_to_db(db_path)
    query1 = f&#39;&#39;&#39;select name from sqlite_{name_new}
                 where type = &#34;table&#34; and name not like &#34;sqlite_%&#34;&#39;&#39;&#39;
    query2 = f&#39;&#39;&#39;select name from sqlite_{name_old}
                 where type = &#34;table&#34; and name not like &#34;sqlite_%&#34;&#39;&#39;&#39;
    try:
        df_tables = pd.read_sql(query1, con)
    except Exception:
        df_tables = pd.read_sql(query2, con)
    tables = df_tables[&#39;name&#39;].to_list()
    return tables


def ansible_get_hostgroup() -&gt; str:
    &#39;&#39;&#39;
    Get the Ansible hostgroup.

    Returns
    -------
    hostgroup : str
        The Ansible hostgroup.

    Examples
    --------
    &gt;&gt;&gt; hostgroup = ansible_get_hostgroup()
    &gt;&gt;&gt; print(hostgroup)
    &#39;&#39;&#39;

    host_group = input(&#39;Enter the name of the host group in the hosts file: &#39;)
    return host_group


def ansible_get_host_variables(host_group: str, private_data_dir: str) -&gt; Dict:
    &#39;&#39;&#39;
    Get the variables for a host or host group in the hosts file.

    Parameters
    ----------
    host_group : str
        The name of the host group.
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the path that
        the &#39;inventory&#39; folder is in. The default is the current folder.

    Returns
    -------
    group_vars : dict
        The host group variables.

    Examples
    --------
    &gt;&gt;&gt; host_group = &#39;&lt;host_group&gt;&#39;
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; group_vars = ansible_get_host_variables(host_group, private_data_dir)
    &gt;&gt;&gt; print(group_vars)
    &#39;&#39;&#39;
    # Read the contents of the playbook into a dictionary
    with open(f&#39;{private_data_dir}/inventory/hosts&#39;) as f:
        hosts = yaml.load(f, Loader=yaml.FullLoader)

    group_vars = hosts[host_group][&#39;vars&#39;]

    return group_vars


def ansible_get_hostgroup_devices(hostgroup: str,
                                  host_files: List[str],
                                  quiet: bool = True) -&gt; List[str]:
    &#39;&#39;&#39;
    Get the devices inside an Ansible inventory hostgroup.

    Parameters
    ----------
    hostgroup : str
        The Ansible hostgroup.
    host_files : list
        The path to one or more Ansible host files (e.g., [&#39;inventory/hosts&#39;]).
    quiet : bool, optional
        Whether to output the entire graph. Defaults to True.

    Returns
    -------
    devices : list
        A list of devices in the hostgroup.

    Examples
    --------
    &gt;&gt;&gt; hostgroup = &#39;&lt;hostgroup&gt;&#39;
    &gt;&gt;&gt; host_files = [&#39;inventory/hosts&#39;]
    &gt;&gt;&gt; devices = ansible_get_hostgroup_devices(hostgroup, host_files)
    &gt;&gt;&gt; print(devices)
    &#39;&#39;&#39;
    graph = ansible_runner.interface.get_inventory(&#39;graph&#39;,
                                                   host_files,
                                                   quiet=True)
    graph = str(graph)
    for item in graph.split(&#39;@&#39;):
        if hostgroup in item:
            item = item.split(&#39;:&#39;)[-1]
            item = item.split(&#39;|--&#39;)[1:-1]
            devices = [i.split(&#39;\\&#39;)[0] for i in item]
            break
    return devices


def ansible_group_hostgroups_by_os(private_data_dir: str) \
        -&gt; Dict[str, List[str]]:
    &#39;&#39;&#39;
    Finds the ansible_network_os for all hostgroups that have defined it in the
    variables, then organizes the hostgroups by os.

    For example:

    groups_os[&#39;cisco.asa.asa&#39;] = [&#39;asa_group_1&#39;]
    groups_os[&#39;cisco.nxos.nxos&#39;] = [&#39;nxos_group_1&#39;, &#39;nxos_group_2&#39;]

    Parameters
    ----------
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the path that the
        &#39;inventory&#39; folder is in. The default is the current folder.

    Returns
    -------
    hostgroup_by_os : dict
        A dictionary containing the hostgroups, grouped by OS.

    Examples
    --------
    &gt;&gt;&gt; private_data_dir = &#39;&lt;private_data_dir&gt;&#39;
    &gt;&gt;&gt; hostgroup_by_os = ansible_group_hostgroups_by_os(private_data_dir)
    &gt;&gt;&gt; print(hostgroup_by_os)
    &#39;&#39;&#39;
    # Get the OS for all Ansible hostgroups
    groups_os = ansible_get_all_hostgroup_os(private_data_dir)

    # Extract the OS and create dict for all hostgroups that have defined it
    groups_by_os = dict()
    for key, value in groups_os.items():
        if not groups_by_os.get(value):
            groups_by_os[value] = list()
        groups_by_os[value].append(key)
    return groups_by_os


def define_collectors(hostgroup: str) -&gt; Dict[str, Any]:
    &#39;&#39;&#39;
    Creates a list of collectors.

    Parameters
    ----------
    hostgroup : str
        The name of the hostgroup.

    Returns
    -------
    available : dict
        The collectors supported by the hostgroup.

    Examples
    --------
    &gt;&gt;&gt; hostgroup = &#39;&lt;hostgroup&gt;&#39;
    &gt;&gt;&gt; available = define_collectors(hostgroup)
    &gt;&gt;&gt; print(available)
    &#39;&#39;&#39;
    # TODO: Find a more dynamic way to create this dictionary
    collectors = {&#39;arp_table&#39;: [&#39;bigip&#39;,
                                &#39;cisco.ios.ios&#39;,
                                &#39;cisco.nxos.nxos&#39;,
                                &#39;paloaltonetworks.panos&#39;],
                  &#39;cam_table&#39;: [&#39;cisco.ios.ios&#39;, &#39;cisco.nxos.nxos&#39;],
                  &#39;config&#39;: [&#39;cisco.ios.ios&#39;],
                  &#39;devices_inventory&#39;: [&#39;cisco.dnac&#39;],
                  &#39;devices_modules&#39;: [&#39;cisco.dnac&#39;],
                  &#39;ncm_serial_numbers&#39;: [&#39;solarwinds&#39;],
                  &#39;network_appliance_vlans&#39;: [&#39;meraki&#39;],
                  &#39;npm_containers&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_group_members&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_group_names&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_ids&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_ips&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_machine_types&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_os_versions&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_vendors&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_nodes&#39;: [&#39;solarwinds&#39;],
                  &#39;node_availability&#39;: [&#39;bigip&#39;],
                  &#39;pool_availability&#39;: [&#39;bigip&#39;],
                  &#39;pool_member_availability&#39;: [&#39;bigip&#39;],
                  &#39;pool_summary&#39;: [&#39;bigip&#39;],
                  &#39;self_ips&#39;: [&#39;bigip&#39;],
                  &#39;vip_availability&#39;: [&#39;bigip&#39;],
                  &#39;vip_destinations&#39;: [&#39;bigip&#39;],
                  #  &#39;vip_summary&#39;: [&#39;bigip&#39;],
                  &#39;vlans&#39;: [&#39;bigip&#39;,
                            &#39;cisco.ios.ios&#39;,
                            &#39;cisco.nxos.nxos&#39;,
                            &#39;infoblox_nios&#39;],
                  &#39;networks&#39;: [&#39;infoblox_nios&#39;],
                  &#39;network_containers&#39;: [&#39;infoblox_nios&#39;],
                  &#39;networks_parent_containers&#39;: [&#39;infoblox_nios&#39;],
                  &#39;vlan_ranges&#39;: [&#39;infoblox_nios&#39;],
                  &#39;interface_description&#39;: [&#39;bigip&#39;,
                                            &#39;cisco.ios.ios&#39;,
                                            &#39;cisco.nxos.nxos&#39;],
                  &#39;interface_ip_addresses&#39;: [&#39;cisco.asa.asa&#39;,
                                             &#39;cisco.ios.ios&#39;,
                                             &#39;cisco.nxos.nxos&#39;,
                                             &#39;paloaltonetworks.panos&#39;],
                  &#39;interface_status&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;interface_summary&#39;: [&#39;bigip&#39;, &#39;cisco.nxos.nxos&#39;],
                  &#39;inventory_nxos&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;network_clients&#39;: [&#39;meraki&#39;],
                  &#39;network_devices&#39;: [&#39;meraki&#39;],
                  &#39;network_device_statuses&#39;: [&#39;meraki&#39;],
                  &#39;organizations&#39;: [&#39;meraki&#39;],
                  &#39;org_devices&#39;: [&#39;meraki&#39;],
                  &#39;org_device_statuses&#39;: [&#39;meraki&#39;],
                  &#39;org_networks&#39;: [&#39;meraki&#39;],
                  &#39;switch_port_statuses&#39;: [&#39;meraki&#39;],
                  &#39;switch_lldp_neighbors&#39;: [&#39;meraki&#39;],
                  &#39;switch_port_usages&#39;: [&#39;meraki&#39;],
                  &#39;ipam_prefixes&#39;: [&#39;netbox&#39;],
                  &#39;all_interfaces&#39;: [&#39;paloaltonetworks.panos&#39;],
                  &#39;logical_interfaces&#39;: [&#39;paloaltonetworks.panos&#39;],
                  &#39;physical_interfaces&#39;: [&#39;paloaltonetworks.panos&#39;],
                  &#39;port_channel_data&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;vpc_state&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;vrfs&#39;: [&#39;cisco.ios.ios&#39;, &#39;cisco.nxos.nxos&#39;]}

    available = list()
    for key, value in collectors.items():
        if hostgroup in value:
            available.append(key)
    return available


def f5_create_authentication_token(device: str,
                                   username: str,
                                   password: str,
                                   loginProviderName: str = &#39;tmos&#39;,
                                   verify: bool = True) -&gt; str:
    &#39;&#39;&#39;
    Creates an authentication token to use for F5 REST API calls.

    Parameters
    ----------
    device : str
        The device name or IP address.
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.
    loginProviderName : str, optional
        The value to use for &#39;loginProviderName&#39;. Defaults to &#39;tmos&#39;.
        It should only need to be changed if F5 documentation or support
        says it is necessary.
    verify : bool, optional
        Whether to verify certs. Defaults to &#39;True&#39;. Should only be set
        to &#39;False&#39; if it is a dev environment or the F5 is using
        self-signed certificates.

    Returns
    -------
    token : str
        The authentication token.
    &#39;&#39;&#39;
    # Create the URL used for creating the authentication token
    url = f&#39;{device}/mgmt/shared/authn/login&#39;

    # Request the token
    content = {&#39;username&#39;: username,
               &#39;password&#39;: password,
               &#39;loginProviderName&#39;: loginProviderName}
    response = requests.post(url, json=content, verify=verify)
    token = response.json()[&#39;token&#39;][&#39;token&#39;]

    # Sleep for 1.5 seconds. This is required due to F5 bug ID1108181
    # https://cdn.f5.com/product/bugtracker/ID1108181.html
    time.sleep(1.5)

    # Return the token
    return token


def find_mac_vendors(macs: List[str], nm_path: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Finds the vendor OUI for a list of MAC addresses.

    Parameters
    ----------
    macs : list
        A list containing the MAC addresses for which to find the OUIs.
    nm_path : str
        The path to the Net-Manage repository.

    Returns
    -------
    df : DataFrame
        A Pandas DataFrame containing two columns. The first is the MAC
        address, and the second is the corresponding vendor.

    Notes
    -----
    There is a Python library to do this, but it is quite slow.

    It might seem inefficient to parse the OUIs from a text file on an
    as-needed basis. However, testing found that the operation only takes
    about 250ms, and the size of the resulting dataframe is only
    approximately 500KB.

    Examples
    --------
    &gt;&gt;&gt; import os
    &gt;&gt;&gt; macs = [&#39;00:50:56:bd:52:79&#39;, &#39;c4:34:6b:b9:99:32&#39;]
    &gt;&gt;&gt; home_dir = os.path.expanduser(&#39;~&#39;)
    &gt;&gt;&gt; nm_path = f&#39;{home_dir}/source/repos/InsightSSG/Net-Manage&#39;
    &gt;&gt;&gt; df = find_mac_vendors(macs, nm_path)
    &gt;&gt;&gt; print(df.to_dict())
    {&#39;mac&#39;: {0: &#39;00:50:56:bd:52:79&#39;, 1: &#39;c4:34:6b:b9:99:32&#39;},
    &#39;vendor&#39;: {0: &#39;VMware, Inc.&#39;, 1: &#39;Hewlett Packard&#39;}}
    &#39;&#39;&#39;
    # Convert MAC addresses to base 16 by removing special characters.
    addresses = [&#39;&#39;.join(filter(str.isalnum, _)).upper() for _ in macs]

    # Create a list to store vendors
    vendors = list()

    # Check if the list of OUIs exists and/or needs to be updated.
    df_ouis = update_ouis(nm_path)

    # Search df_ouis for the vendor and add it to &#39;vendors&#39;.
    for address in addresses:
        vendor = df_ouis.loc[df_ouis[&#39;base&#39;] == address[:6]][&#39;vendor&#39;]
        if len(vendor) &gt;= 1:
            vendors.append(vendor.squeeze())
        else:
            vendors.append(&#39;unknown&#39;)

    # Create the dataframe.
    df = pd.DataFrame()
    df[&#39;mac&#39;] = macs
    df[&#39;vendor&#39;] = vendors

    return df


def generate_subnet_details(addresses: List[str],
                            return_keys: List[str] = [&#39;subnet&#39;,
                                                      &#39;network_ip&#39;,
                                                      &#39;broadcast_ip&#39;]) \
        -&gt; Dict[str, List[str]]:
    &#39;&#39;&#39;
    Generates the subnet, network, and broadcast IPs for a list of IPs.

    Parameters
    ----------
    addresses : list of str
        List of IP addresses in the format {ip}/{subnet_mask_length}.
    return_keys : list of str, optional
        List of keys to return. Used for when a table has column names that
        conflict with the default return_keys of &#39;subnet&#39;, &#39;network_ip&#39;, and
        &#39;broadcast_ip&#39;. NOTE: The keys should be ordered so that element[0]
        is for the &#39;subnet&#39; column, element[1] for &#39;network_ip&#39;, and element[2]
        for &#39;broadcast_ip&#39;. Defaults to [&#39;subnet&#39;,&#39;network_ip&#39;,&#39;broadcast_ip&#39;].

    Returns
    -------
    dict
        A dictionary with three keys:
        - &#39;subnet&#39; : list of str
            List of subnet in CIDR notation for each IP address in the input
            list.
        - &#39;network_ip&#39; : list of str
            List of network IP for each IP address in the input list.
        - &#39;broadcast_ip&#39; : list of str
            List of broadcast IP for each IP address in the input list.
    &#39;&#39;&#39;
    subnet = list()
    network_ip = list()
    broadcast_ip = list()

    for ip in addresses:
        ip_obj = ipaddress.ip_interface(ip)
        subnet.append(str(ip_obj.network))
        network_ip.append(str(ip_obj.network.network_address))
        brd = str(ipaddress.IPv4Address(int(ip_obj.network.broadcast_address)))
        broadcast_ip.append(brd)

    return {return_keys[0]: subnet,
            return_keys[1]: network_ip,
            return_keys[2]: broadcast_ip}


def get_creds(prompt: str = &#39;&#39;) -&gt; Tuple[str, str]:
    &#39;&#39;&#39;
    Gets the username and password to use for authentication.

    Parameters
    ----------
    prompt : str, optional
        A one-word description to use inside the prompt. For example, if
        prompt == &#39;device&#39;, then the user would be presented with the full
        prompt of &#39;Enter the username to use for device authentication.&#39; If no
        prompt is passed to the function, then the generic prompt will be used.
        Defaults to &#39;&#39;.

    Returns
    -------
    username : str
        The username.
    password : str
        The password.
    &#39;&#39;&#39;
    username = get_username(prompt)
    password = get_password(prompt)
    return username, password


def ansible_get_hostgroups(inventories: List[str],
                           quiet: bool = True) -&gt; List[str]:
    &#39;&#39;&#39;
    Gets the devices inside an Ansible inventory hostgroup.

    Parameters
    ----------
    inventories : list of str
        The path to one or more Ansible host files (e.g.,
        [&#39;inventory/hosts&#39;]).
    quiet : bool, optional
        Whether to output the entire graph. Defaults to True.

    Returns
    -------
    devices : list of str
        A list of devices in the hostgroup.
    &#39;&#39;&#39;
    graph = ansible_runner.interface.get_inventory(&#39;graph&#39;,
                                                   inventories,
                                                   quiet=True)
    graph = str(graph).strip(&#34;(&#39;&#34;)
    # graph = list(filter(None, graph))
    hostgroups = list()
    graph = list(filter(None, graph.split(&#39;@&#39;)))
    # TODO: Write a better parser
    for item in graph:
        hostgroup = item.split(&#39;:&#39;)[0]
        hostgroups.append(hostgroup)
    return hostgroups


def connect_to_db(db: str) -&gt; sl.Connection:
    &#39;&#39;&#39;
    Opens a connection to the sqlite database.

    Parameters
    ----------
    db : str
        Path to the database

    Returns
    -------
    con : sl.Connection
        Connection to the database
    &#39;&#39;&#39;
    try:
        con = sl.connect(db)
    except Exception as e:
        if str(e) == &#39;unable to open database file&#39;:
            print(f&#39;Cannot connect to db &#34;{db}&#34;. Does directory exist?&#39;)
            sys.exit()
        else:
            print(f&#39;Caught exception &#34;{str(e)}&#34;&#39;)
            sys.exit()
    return con


def create_sqlite_regexp_function(conn: sl.Connection) -&gt; None:
    &#39;&#39;&#39;
    Creates a SQLite3 function that allows REGEXP queries. More details can be
    found at the following URLs:
    - &#39;https://tinyurl.com/mwxz2dn8&#39;
    - &#39;https://tinyurl.com/ye285mnj&#39;

    Parameters
    ----------
    conn : sqlite3.Connection
        An object for connecting to the sqlite3 database.

    Returns
    -------
    None
    &#39;&#39;&#39;
    # This function is credited to Stack Overflow user &#39;unutbu&#39;:
    # - https://tinyurl.com/ye285mnj
    def regexp(expr, item):
        reg = re.compile(expr)
        return reg.search(item) is not None
    conn.create_function(&#39;REGEXP&#39;, 2, regexp)


def get_dir_timestamps(path: str) -&gt; Dict[str, dt]:
    &#39;&#39;&#39;
    Gets the timestamp for all files and folders in a directory.

    This function is not recursive.

    Parameters
    ----------
    path : str
        The path to search.

    Returns
    -------
    result : dict
        A dictionary for each file or folder, where the key is the file or
        folder name and the value is a datetime object containing the
        timestamp.

    Examples
    --------
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; path = &#39;/tmp/test/&#39;
    &gt;&gt;&gt; result = get_dir_timestamps(path)
    &gt;&gt;&gt; pprint(result)
    {&#39;/tmp/test/test.txt&#39;: datetime.datetime(2023, 3, 7, 16, 15, 9),
    &#39;/tmp/test/test2.txt&#39;: datetime.datetime(2023, 3, 7, 16, 16, 4)}
    &#39;&#39;&#39;
    files = glob.glob(f&#39;{path}/*&#39;)

    result = dict()
    for file in files:
        ts = time.ctime(os.path.getctime(file)).split()
        ts = &#39; &#39;.join([ts[1], ts[2], ts[-1], ts[3]])
        result[file] = dt.strptime(ts, &#34;%b %d %Y %H:%M:%S&#34;)

    return result


def get_first_last_timestamp(db_path: str,
                             table: str,
                             col_name: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets the first and last timestamp from a database table for each unique
    entry in a column.

    Parameters
    ----------
    db_path : str
        The path to the database.
    table : str
        The table name.
    col_name : str
        The column name to search by (e.g., &#39;device&#39;, &#39;networkId&#39;, etc).

    Returns
    -------
    df_stamps : DataFrame
        A DataFrame containing the first and last timestamp for each unique
        entry in the specified column.
    &#39;&#39;&#39;
    df_data = dict()
    df_data[col_name] = list()
    df_data[&#39;first_ts&#39;] = list()
    df_data[&#39;last_ts&#39;] = list()

    # Get the unique entries for col_name (usually a device name, MAC address,
    # etc). This is necessary since the first timestamp in the table won&#39;t
    # always have all the entries for that table (devices might be added or
    # removed, ARP tables might change, and so on)
    con = sl.connect(db_path)
    query = f&#39;select distinct {col_name} from {table}&#39;
    df_uniques = pd.read_sql(query, con)
    uniques = df_uniques[col_name].to_list()

    # Create a dictionary to store the first and last timestamps for col_name.
    # This will be used to create df_stamps
    # df_data = dict()

    query = f&#39;select distinct timestamp from {table}&#39;
    timestamps = pd.read_sql(query, con)[&#39;timestamp&#39;].to_list()

    for unique in uniques:
        stamps = list()
        for ts in timestamps:
            query = f&#39;&#39;&#39;select timestamp from {table}
                        where timestamp = &#34;{ts}&#34; and {col_name} = &#34;{unique}&#34;&#39;&#39;&#39;
            for item in pd.read_sql(query, con)[&#39;timestamp&#39;].to_list():
                stamps.append(item)
        df_data[col_name].append(unique)
        df_data[&#39;first_ts&#39;].append(stamps[0])
        df_data[&#39;last_ts&#39;].append(stamps[-1])

    # This is an alternative way to collect the first and last timestamps for
    # each col_name. It does not utilize an index (assuming the table has one),
    # but the speed was about the same. I am leaving it here to do more
    # testing with in the future.

    # for unique in uniques:
    #     query = f&#39;&#39;&#39;select distinct timestamp from {table}
    #                 where {col_name} = &#34;{unique}&#34;&#39;&#39;&#39;
    #     df_stamps = pd.read_sql(query, con)
    #     stamps = df_stamps[&#39;timestamp&#39;].to_list()
    #     df_data[col_name].append(unique)
    #     df_data[&#39;first_ts&#39;].append(stamps[0])
    #     df_data[&#39;last_ts&#39;].append(stamps[-1])
    con.close()

    df_stamps = pd.DataFrame.from_dict(df_data)

    return df_stamps


def get_username(prompt: str = &#39;&#39;) -&gt; str:
    &#39;&#39;&#39;
    Gets the username to use for authentication.

    Parameters
    ----------
    prompt : str, optional
        A one-word description to use inside the prompt. For example, if
        prompt == &#39;device&#39;, then the user would be presented with the full
        prompt of &#39;Enter the username to use for device authentication.&#39; If
        no prompt is passed to the function, then the generic prompt will be
        used. Default is an empty string.

    Returns
    -------
    username : str
        The username.
    &#39;&#39;&#39;
    # Create the full prompt
    if not prompt:
        f_prompt = &#39;Enter the username to use for authentication: &#39;
    else:
        f_prompt = f&#39;Enter the username to use for {prompt} authentication: &#39;

    # Get the user&#39;s username
    username = input(f_prompt)

    return username


def get_password(prompt: str = &#39;&#39;) -&gt; str:
    &#39;&#39;&#39;
    Gets the password to use for authentication.

    Parameters
    ----------
    prompt : str, optional
        A one-word description to use inside the prompt. For example, if
        prompt == &#39;device&#39;, then the user would be presented with the full
        prompt of &#39;Enter the username to use for device authentication.&#39; If
        no prompt is passed to the function, then the generic prompt will be
        used. Default is an empty string.

    Returns
    -------
    password : str
        The password.
    &#39;&#39;&#39;
    # Create the full prompt
    if not prompt:
        f_prompt = &#39;Enter the password to use for authentication: &#39;
    else:
        f_prompt = f&#39;Enter the password to use for {prompt} authentication: &#39;

    # Get the user&#39;s password and have them type it twice for verification
    pass1 = str()
    pass2 = None
    while pass1 != pass2:
        pass1 = getpass(f_prompt)
        pass2 = getpass(&#39;Confirm your password: &#39;)
        if pass1 != pass2:
            print(&#39;Error: Passwords do not match.&#39;)
    password = pass1

    return password


def meraki_get_api_key() -&gt; str:
    &#39;&#39;&#39;
    Gets the Meraki API key.

    Returns
    -------
    api_key : str
        The user&#39;s API key.
    &#39;&#39;&#39;
    api_key = getpass(&#39;Enter your Meraki API key: &#39;)
    return api_key


def move_cols_to_end(df: pd.DataFrame, cols: List[str]) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Moves one or more columns on a dataframe to be the end. For example,
    if the dataframe columns are [&#39;A&#39;, &#39;C&#39;, &#39;B&#39;], then this function can be
    used to re-order them to [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;].

    Parameters
    ----------
    df : pd.DataFrame
        The Pandas dataframe to re-order.
    cols : list of str
        A list of one or more columns to move. If more than one column is
        specified, they will be added to the end in the order that is in
        the list.

    Returns
    -------
    pd.DataFrame
        The re-ordered DataFrame.
    &#39;&#39;&#39;
    for c in cols:
        df[c] = df.pop(c)
    return df


def read_table(db_path: str, table: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Reads all columns for the latest timestamp from a database table.

    Parameters
    ----------
    db_path : str
        The full path to the database.
    table : str
        The table name.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the data.
    &#39;&#39;&#39;
    con = connect_to_db(db_path)
    df_ts = pd.read_sql(f&#39;select timestamp from {table} limit 1&#39;, con)
    ts = df_ts[&#39;timestamp&#39;].to_list()[-1]
    df = pd.read_sql(f&#39;select * from {table} where timestamp = &#34;{ts}&#34;&#39;, con)
    con.close()
    return df


def set_dependencies(selected: List[str]) -&gt; List[str]:
    &#39;&#39;&#39;
    Ensures that dependent collectors are added to the selection. For example,
    collecting &#39;f5_vip_destinations&#39; requires collecting &#39;f5_vip_availability&#39;.
    If a user has selected the former without selecting the latter, then this
    function adds the latter (in the proper order) to the selection.

    TODO: Currently, all dependencies are within the same hostgroup. By that I
          mean, F5 collectors are dependent on other F5 collectors, Meraki
          collectors are dependent on other Meraki collectors, and so on.
          It is possible that at some point collectors will be dependent on
          hostgroups that the user did not select. If that happens, this
          function will need to be modified accordingly.

    Parameters
    ----------
    selected : list
        The list of selected collectors.

    Returns
    -------
    selected : list
        The updated list of selected collectors.
    &#39;&#39;&#39;
    s = selected
    if &#39;devices_modules&#39; in s:
        if &#39;devices_inventory&#39; in s:
            pos = s.index(&#39;devices_inventory&#39;)
            del s[pos]
        s.insert(0, &#39;devices_inventory&#39;)

    if &#39;interface_summary&#39; in s:
        pos = s.index(&#39;interface_summary&#39;)
        if &#39;cam_table&#39; not in s:
            s.insert(pos, &#39;cam_table&#39;)
        if &#39;interface_description&#39; not in s:
            s.insert(pos, &#39;interface_description&#39;)
        if &#39;interface_status&#39; not in s:
            s.insert(pos, &#39;interface_status&#39;)
    if &#39;get_device_statuses&#39; in s:
        pos1 = s.index(&#39;get_device_statuses&#39;)
        if &#39;get_organizations&#39; in s:
            pos2 = s.index(&#39;get_organizations&#39;)
            if pos2 &gt; pos1:
                del s[pos2]
                s.insert(pos1, &#39;get_organizations&#39;)
        else:
            s.insert(pos1, &#39;get_organizations&#39;)

    if &#39;interface_summary&#39; in s:
        if &#39;cam_table&#39; in s:
            pos = s.index(&#39;cam_table&#39;)
            del s[pos]
        s.insert(0, &#39;cam_table&#39;)

    if &#39;vip_destinations&#39; in s:
        if &#39;vip_availability&#39; in s:
            pos = s.index(&#39;vip_availability&#39;)
            del s[pos]
        s.insert(0, &#39;vip_availability&#39;)

    if &#39;infoblox_get_networks_parent_containers&#39; in s:
        if &#39;infoblox_get_networks&#39; in s:
            pos = s.index(&#39;infoblox_get_networks&#39;)
            del s[pos]
        pos = s.insert(0, &#39;infoblox_get_networks&#39;)
        if &#39;infoblox_get_network_containers&#39; in s:
            pos = s.index(&#39;infoblox_get_network_containers&#39;)
            del s[pos]
        pos = s.insert(0, &#39;infoblox_get_network_containers&#39;)

    if &#39;device_statuses&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;network_appliance_vlans&#39; in s:
        if &#39;org_networks&#39; in s:
            pos = s.index(&#39;org_networks&#39;)
            del s[pos]
        s.insert(0, &#39;org_networks&#39;)

    if &#39;network_device_statuses&#39; in s:
        if &#39;org_device_statuses&#39; in s:
            pos = s.index(&#39;org_device_statuses&#39;)
            del s[pos]
        s.insert(0, &#39;org_device_statuses&#39;)

    if &#39;network_devices&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;org_devices&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;org_device_statuses&#39; in s:
        if &#39;org_networks&#39; in s:
            pos = s.index(&#39;org_networks&#39;)
            del s[pos]
        s.insert(0, &#39;org_networks&#39;)

    if &#39;org_networks&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;switch_lldp_neighbors&#39; in s:
        dependencies = [&#39;switch_port_statuses&#39;]
        for d in dependencies:
            if d in s:
                pos = s.index(d)
                del s[pos]
        for d in dependencies:
            s.insert(0, d)

    if &#39;switch_port_usages&#39; in s:
        if &#39;switch_port_statuses&#39; in s:
            pos = s.index(&#39;switch_port_statuses&#39;)
            del s[pos]
        s.insert(0, &#39;switch_port_statuses&#39;)

    if &#39;switch_port_statuses&#39; in s:
        if &#39;org_devices&#39; in s:
            pos = s.index(&#39;org_devices&#39;)
            del s[pos]
        s.insert(0, &#39;org_devices&#39;)
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;vpn_statuses&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    # Remove duplicate collectors from &#39;s&#39;
    non_dups = list()
    for item in s:
        if item not in non_dups:
            non_dups.append(item)
    s = non_dups

    selected = s
    return s


def set_filepath(filepath: str) -&gt; str:
    &#39;&#39;&#39;
    Creates a filename with the date and time added to a path the user
    provides. The function assumes the last &#34;.&#34; in a filename is the extension.

    Parameters
    ----------
    filepath : str
        The base filepath. Do not include the date; that will be added
        dynamically at runtime.

    Returns
    -------
    filepath : str
        The full path to the modified filename.
    &#39;&#39;&#39;
    # Convert &#39;~&#39; to the user&#39;s home folder
    if &#39;~&#39; in filepath:
        filepath = filepath.replace(&#39;~&#39;, os.path.expanduser(&#39;~&#39;))
    # Set the prefix in YYYY-MM-DD_HHmm format
    prefix = dt.now().strftime(&#34;%Y-%m-%d_%H%M&#34;)
    # Extract the base path to the filename
    filepath = filepath.split(&#39;/&#39;)
    filename = filepath[-1]
    if len(filepath) &gt; 2:
        filepath = &#39;/&#39;.join(filepath[:-1])
    else:
        filepath = filepath[0]
    # Extract the filename and extension from &#39;filepath&#39;
    filename = filename.split(&#39;.&#39;)
    extension = filename[-1]
    if len(filename) &gt; 2:
        filename = &#39;.&#39;.join(filename[:-1])
    else:
        filename = filename[0]
    # Return the modified filename
    filepath = f&#39;{filepath}/{prefix}_{filename}.{extension}&#39;
    return filepath


def suppress_extravars(extravars: dict) -&gt; dict:
    &#39;&#39;&#39;
    ansible_runner.run stores extravars to a file named &#39;extravars&#39; then saves
    it to the local drive. The file is unencrypted, so any sensitive data, like
    usernames and password, are stored in plain text.

    People have complained about this for years. Finally, starting in version
    2.x, the devs added the &#39;suppress_env_files&#39; arg. This keeps extravars from
    being stored locally.

    The sole purpose of this function is to ensure that legacy Ansible-Runner
    commands add that argument. *All ansible_runner.run args should be passed
    to this function, no exceptions.*

    If they do not use extravars, then just pass an empty dict.
    This will ensure the functions are secure if someone adds extravars to them
    later.

    Parameters
    ----------
    extravars : dict
        A dictionary containing the extravars. If your function does not use
        it, then pass an empty dict instead.

    Returns
    -------
    extravars : dict
        &#39;extravars&#39; with the &#39;suppress_env_files&#39; key.
    &#39;&#39;&#39;
    # TODO: Finish this function. (Note: I thought about adding a check to
    #       manually delete any files in extravars at beginning and end of
    #       each run, but users might not want that.)


def get_net_manage_path() -&gt; str:
    &#39;&#39;&#39;
    Set the absolute path to the Net-Manage repository.

    Returns
    -------
    nm_path : str
        The absolute path to the Net-Manage repository.
    &#39;&#39;&#39;
    nm_path = input(&#34;Enter the absolute path to the Net-Manage repository: &#34;)
    nm_path = os.path.expanduser(nm_path)
    return nm_path


def set_db_timestamp() -&gt; str:
    &#39;&#39;&#39;
    Sets a timestamp in the form the database expects.

    Returns
    -------
    timestamp : str
        A timestamp in the YYYY-MM-DD_hhmm format.
    &#39;&#39;&#39;
    timestamp = dt.now()
    timestamp = timestamp.strftime(&#39;%Y-%m-%d_%H%M&#39;)
    return timestamp


def set_vars() -&gt; Tuple[str, str, List[str], str, str, str]:
    &#39;&#39;&#39;
    Prompts the user for the required variables for running collectors and
    validators. Several defaults are presented.

    Note: The &#39;inventories&#39; argument is a list of inventory files. Currently,
    the function statically defines it as [&#39;private_data_dir/inventory/hosts&#39;].
    If users want to use different file names or more than one file name,
    that functionality can be added later.

    Returns
    -------
    api_key : str
        The api key.
    db_path : str
        The path to the database.
    inventories : list of str
        The list of inventory files.
    nm_path : str
        The path to the nm.
    out_path : str
        The path for output.
    private_data_dir : str
        The private data directory.
    &#39;&#39;&#39;
    default_db = f&#39;{str(dt.now()).split()[0]}.db&#39;
    default_nm_path = &#39;~/source/repos/InsightSSG/Net-Manage/&#39;

    db = input(f&#39;Enter the name of the database: [{default_db}]&#39;)
    nm_path = input(f&#39;Enter path to Net-Manage repository [{default_nm_path}]&#39;)
    private_data_dir = input(&#39;Enter the path to the private data directory:&#39;)

    npm_server = input(&#39;Enter the URL of the Solarwinds NPM server:&#39;)
    npm_username = input(&#39;Enter the username for Solarwinds NPM:&#39;)
    npm_password = getpass(&#39;Enter the password for Solarwinds NPM:&#39;)

    default_out_path = f&#39;{private_data_dir}/output&#39;
    out_path = input(f&#39;Enter the path to store results: [{default_out_path}]&#39;)

    api_key = meraki_get_api_key()

    if not db:
        db = default_db
    if not nm_path:
        nm_path = default_nm_path
    if not out_path:
        out_path = default_out_path

    if not npm_server:
        npm_server = str()
    if not npm_username:
        npm_username = str()
    if not npm_password:
        npm_password = str()

    db = os.path.expanduser(db)
    nm_path = os.path.expanduser(nm_path)
    out_path = os.path.expanduser(out_path)
    private_data_dir = os.path.expanduser(private_data_dir)
    db_path = f&#39;{out_path}/{db}&#39;

    # TODO: Add support for a custom inventory file name
    # TODO: Add support for more than one inventory file (Ansible-Runner
    #       supports that, but I am not sure how common it is)
    inventories = [f&#39;{private_data_dir}/inventory/hosts&#39;]

    return api_key, db, db_path, inventories, npm_server, npm_username, \
        npm_password, nm_path, out_path, private_data_dir


def get_tests_file() -&gt; str:
    &#39;&#39;&#39;
    Set the absolute path to the Net-Manage repository.

    Returns
    -------
    t_path : str
        The absolute path to the file containing tests to run.
    &#39;&#39;&#39;
    t_file = input(&#34;Enter the absolute path to the Net-Manage repository: &#34;)
    t_file = os.path.expanduser(t_file)
    return t_file


def get_user_meraki_input() -&gt; Tuple[List[str],
                                     List[str],
                                     List[str],
                                     int,
                                     int,
                                     Union[int, str]]:
    &#39;&#39;&#39;
    Gets and parses user input when they select collectors for Meraki
    organizations.

    Returns
    -------
    orgs : list
        A list of one or more organizations. Defaults to an empty list.
    networks : list
        A list of one or more networks. Defaults to an empty list.
    macs : list
        A list of one or more MAC addresses. Partial addresses are accepted.
        Defaults to an empty list.
    timespan : int
        The lookback timespan in seconds. Defaults to 1 day (86400 seconds).
        If a user has an * between numbers, it will multiply them. It does not
        perform any other calculation (addition, subtraction, etc).
    per_page : int
        The number of results to return per page. Defaults to 10. It is
        recommended to leave it at 10, as increasing the number of results
        can reduce performance. However, increasing it might be worth trying
        when working with large datasets.
    total_pages : int or str
        The total number of pages to return. If input is &#39;all&#39;, returns as
        &#39;all&#39;. Otherwise, converts the input into an integer. Defaults to
        &#39;all&#39;.
    &#39;&#39;&#39;
    orgs = input(&#39;Enter a comma-delimited list of organizations to query: &#39;)\
        or list()
    if orgs:
        orgs = [_.strip() for _ in orgs.split(&#39;,&#39;)]

    networks = input(&#39;Enter a comma-delimited list of networks to query: &#39;)\
        or list()
    if networks:
        networks = [_.strip() for _ in networks.split(&#39;,&#39;)]

    macs = input(&#39;Enter a comma-delimited list of MAC addresses: &#39;) or list()
    if macs:
        macs = [_.strip() for _ in macs.split(&#39;,&#39;)]

    timespan = input(&#39;Enter the lookback timespan in seconds: &#39;) or &#39;86400&#39;
    timespan = np.prod([int(_) for _ in timespan.split(&#39;*&#39;)])

    per_page = int(input(&#39;Enter the number of results per page: &#39;) or 10)

    total_pages = input(&#39;Enter the total number of pages to return: &#39;) or &#39;all&#39;
    if total_pages[0].isdigit() or total_pages[0] == &#39;-&#39;:
        total_pages = int(total_pages)

    return orgs, networks, macs, timespan, per_page, total_pages


def meraki_check_api_enablement(db_path: str, org: str) -&gt; bool:
    &#39;&#39;&#39;
    Queries the database to find if API access is enabled.

    Parameters
    ----------
    db_path : str
        The path to the database to store results.
    org : str
        The organization to check API access for.

    Returns
    -------
    enabled : bool
        A boolean indicating whether API access is enabled for the user&#39;s API
        key.
    &#39;&#39;&#39;
    # enabled = False

    query = [&#39;SELECT timestamp, api from MERAKI_ORGANIZATIONS&#39;,
             f&#39;WHERE id = &#34;{org}&#34;&#39;,
             &#39;ORDER BY timestamp DESC&#39;,
             &#39;limit 1&#39;]
    query = &#39; &#39;.join(query)

    con = sl.connect(db_path)
    result = pd.read_sql(query, con)
    con.close()
    return ast.literal_eval(result.iloc[0][&#39;api&#39;])[&#39;enabled&#39;]

    # if result[&#39;api&#39;].to_list()[0] == &#39;True&#39;:
    #     enabled = True

    # return enabled


def meraki_map_network_to_organization(network: str, db_path: str) -&gt; str:
    &#39;&#39;&#39;
    Gets the organization ID for a network.

    Parameters
    ----------
    network : str
        A network ID.
    db_path : str
        The path to the database.

    Returns
    -------
    org_id : str
        The organization ID.
    &#39;&#39;&#39;
    query = f&#39;&#39;&#39;SELECT distinct timestamp, organizationId
                FROM MERAKI_ORG_NETWORKS
                WHERE id = &#34;{network}&#34;
                ORDER BY timestamp desc
                LIMIT 1
             &#39;&#39;&#39;
    con = sl.connect(db_path)
    result = pd.read_sql(query, con)
    con.close()

    org_id = result[&#39;organizationId&#39;].to_list()[0]

    return org_id


def meraki_parse_organizations(db_path: str,
                               orgs: list = None,
                               table: str = None) -&gt; list:
    &#39;&#39;&#39;
    Parses a list of organizations that are passed to certain Meraki
    collectors.

    Parameters
    ----------
    db_path : str
        The path to the database to store results.
    orgs : list, optional
        One or more organization IDs. If none are specified, then the
        networks for all orgs will be returned. Defaults to None.
    table : str, optional
        The database table to query. Defaults to None.

    Returns
    -------
    organizations : list
        A list of organizations.
    &#39;&#39;&#39;
    con = sl.connect(db_path)
    organizations = list()
    if orgs:
        for org in orgs:
            df_orgs = pd.read_sql(f&#39;select distinct id from {table} \
                where id = &#34;{org}&#34;&#39;, con)
            organizations.append(df_orgs[&#39;id&#39;].to_list().pop())
    else:
        df_orgs = pd.read_sql(f&#39;select distinct id from {table}&#39;, con)
        for org in df_orgs[&#39;id&#39;].to_list():
            organizations.append(org)
    con.close()

    return organizations


def sql_get_table_schema(db_path: str, table: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets the schema of a table.

    Parameters
    ----------
    db_path : str
        The path to the database.
    table : str
        The table from which to get the schema.

    Returns
    -------
    df_schema : pd.DataFrame
        The table schema. If the table does not exist then an empty dataframe
        will be returned.
    &#39;&#39;&#39;
    query = f&#39;pragma table_info(&#34;{table}&#34;)&#39;

    con = sl.connect(db_path)
    df_schema = pd.read_sql(query, con)

    return df_schema


def download_ouis(path: str) -&gt; None:
    &#39;&#39;&#39;
    Downloads vendor OUIs from https://standards-oui.ieee.org/.

    The results will be stored in a text file located at &#39;path&#39;.

    Parameters
    ----------
    path : str
        The full path to the filename to store the results.

    Raises
    ----------
    FileNotFoundError
        If the directory in the path does not exist.
    IsADirectoryError
        If a filename was not included in &#39;path&#39;.

    Examples
    ----------
    &gt;&gt;&gt; path = &#39;/tmp/ouis.txt&#39;
    &gt;&gt;&gt; download_ouis(path)
    &#39;&#39;&#39;
    url = &#39;https://standards-oui.ieee.org/&#39;
    response = requests.get(url, stream=True)
    with open(path, &#39;wb&#39;) as txt:
        for chunk in response.iter_content(chunk_size=1024):
            if chunk:
                txt.write(chunk)


def tabulate_df_head(df: pd.DataFrame) -&gt; None:
    &#39;&#39;&#39;
    Print the first 5 rows of a DataFrame as a table.

    Parameters
    ----------
    df : pandas.DataFrame
        The DataFrame to print.

    Returns
    -------
    None
        This function does not return anything, it simply prints the table.
    &#39;&#39;&#39;
    table_data = df.head().to_dict(&#39;records&#39;)

    print(tabulate(table_data, headers=&#39;keys&#39;, tablefmt=&#39;psql&#39;))


def update_ouis(nm_path: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Download or update vendor OUIs and save them to a file.

    The data is pulled from https://standards-oui.ieee.org/ and saved to a
    text file named &#39;ouis.txt&#39;. If &#39;ouis.txt&#39; does not exist or is more
    than one week old, then it will be downloaded.

    Parameters
    ----------
    nm_path : str
        The path to the Net-Manage repository.

    Notes
    ----------
    There is a Python library to do this, but it is quite slow.

    It might seem inefficient to parse the OUIs from a text file on an
    as-needed basis. However, testing found that the operation only takes
    about 250ms, and the size of the resulting dataframe is only
    approximately 500KB.

    Returns
    ----------
    df : DataFrame
        A Pandas DataFrame containing two columns. The first is the MAC
        address base in base16 format, and the second is the corresponding
        vendor OUI.

    Examples
    ----------
    &gt;&gt;&gt; df = update_ouis(nm_path)
    &gt;&gt;&gt; print(df[:2].to_dict())
    {&#39;mac_base&#39;: {0: &#39;002272&#39;, 1: &#39;00D0EF&#39;},
    &#39;vendor_oui&#39;: {0: &#39;American Micro-Fuel Device Corp.&#39;, 1: &#39;IGT&#39;}}
    &#39;&#39;&#39;
    # Check if &#39;ouis.txt&#39; exists in &#39;nm_path&#39;, and, if so, get the timestamp.
    files = get_dir_timestamps(nm_path)

    # Check if &#39;ouis.txt&#39; needs to be downloaded.
    download = False
    if f&#39;{nm_path}/ouis.txt&#39; not in files:
        download = True
    else:
        delta = (dt.now().date() - files[f&#39;{nm_path}/ouis.txt&#39;].date()).days
        if delta &gt; 7:
            download = True

    # Download &#39;ouis.txt&#39;, if applicable.
    if download:
        download_ouis(f&#39;{nm_path}/ouis.txt&#39;)

    # Read &#39;ouis.txt&#39; and extract the base16 and vendor combinations.
    with open(f&#39;{nm_path}/ouis.txt&#39;, &#39;r&#39;) as txt:
        data = txt.read()
    pattern = &#39;.*base 16.*&#39;
    data = re.findall(pattern, data)
    data = [[_.split()[0], _.split(&#39;\t&#39;)[-1]] for _ in data]
    df = pd.DataFrame(data=data, columns=[&#39;base&#39;, &#39;vendor&#39;])

    return df


def validate_table(table: str, db_path: str, diff_col: List[str]) -&gt; None:
    &#39;&#39;&#39;
    Validates a table, based on the columns that the user passes to the
    function.

    Args:
        table : str
            The table to validate.
        db_path : str
            The path to the database.
        diff_col : list of str
            The column to diff. It should contain two items:
            - item1: The column to diff (e.g., &#39;status&#39;).
            - item2: The expected state (e.g., &#39;online&#39;).
    &#39;&#39;&#39;
    # Get the first and last timestamps from the table
    con = sl.connect(db_path)
    query = f&#39;select distinct timestamp from {table}&#39;
    df_stamps = pd.read_sql(query, con)
    stamps = df_stamps[&#39;timestamp&#39;].to_list()
    first_ts = stamps[0]
    last_ts = stamps[-1]

    # Execute the queries and diff the results
    query1 = f&#39;{diff_col[0]} = &#34;{diff_col[1]}&#34; and timestamp = &#34;{first_ts}&#34;&#39;
    query2 = f&#39;{diff_col[0]} = &#34;{diff_col[1]}&#34; and timestamp = &#34;{last_ts}&#34;&#39;
    query = f&#39;&#39;&#39;select *
                from {table}
                where {query1}
                except
                select *
                from {table}
                where {query2}
                &#39;&#39;&#39;
    df_diff = pd.read_sql(query, con)
    return df_diff</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="helpers.helpers.ansible_create_collectors_df"><code class="name flex">
<span>def <span class="ident">ansible_create_collectors_df</span></span>(<span>hostgroups: List[str], collectors: List[str]) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DataFrame where the index is the selected collectors and each row
contains a comma-delimited string of selected hostgroups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostgroups</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of hostgroups, each of which is a comma-delimited string.</dd>
<dt><strong><code>collectors</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of one or more collectors, each of which is a comma-delimited
string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_collectors</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame created from hostgroups and collectors.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; hostgroups = ['hostgroup1', 'hostgroup2']
&gt;&gt;&gt; collectors = ['collector1', 'collector2']
&gt;&gt;&gt; df_collectors = ansible_create_collectors_df(hostgroups, collectors)
&gt;&gt;&gt; print(df_collectors)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_create_collectors_df(hostgroups: List[str],
                                 collectors: List[str]) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Create a DataFrame where the index is the selected collectors and each row
    contains a comma-delimited string of selected hostgroups.

    Parameters
    ----------
    hostgroups : list of str
        A list of hostgroups, each of which is a comma-delimited string.
    collectors : list of str
        A list of one or more collectors, each of which is a comma-delimited
        string.

    Returns
    -------
    df_collectors : pd.DataFrame
        A DataFrame created from hostgroups and collectors.

    Examples
    --------
    &gt;&gt;&gt; hostgroups = [&#39;hostgroup1&#39;, &#39;hostgroup2&#39;]
    &gt;&gt;&gt; collectors = [&#39;collector1&#39;, &#39;collector2&#39;]
    &gt;&gt;&gt; df_collectors = ansible_create_collectors_df(hostgroups, collectors)
    &gt;&gt;&gt; print(df_collectors)
    &#39;&#39;&#39;
    df_data = list()
    for c in collectors:
        df_data.append([c, &#39;,&#39;.join(hostgroups)])
        df_collectors = pd.DataFrame(data=df_data, columns=[&#39;collector&#39;,
                                                            &#39;hostgroups&#39;])
    df_collectors = df_collectors.set_index(&#39;collector&#39;)

    return df_collectors</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_create_vars_df"><code class="name flex">
<span>def <span class="ident">ansible_create_vars_df</span></span>(<span>hostgroups: List[str], private_data_dir: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Create a DataFrame containing the Ansible variables for each hostgroup.</p>
<p>This function is designed to be used with the net-manage.ipynb. It reads
all the host groups from the 'df_test', gets the Ansible variables for each
group from the host file, creates a DataFrame containing the variables,
then returns it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostgroups</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of hostgroups.</dd>
<dt><strong><code>private_data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Ansible private_data_dir, which is the directory
containing the 'inventory' folder. The default is the current folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_vars</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the group variables.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; hostgroups = ['group1', 'group2']
&gt;&gt;&gt; private_data_dir = '/path/to/private/data/dir'
&gt;&gt;&gt; df_vars = ansible_create_vars_df(hostgroups, private_data_dir)
&gt;&gt;&gt; print(df_vars)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_create_vars_df(hostgroups: List[str],
                           private_data_dir: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Create a DataFrame containing the Ansible variables for each hostgroup.

    This function is designed to be used with the net-manage.ipynb. It reads
    all the host groups from the &#39;df_test&#39;, gets the Ansible variables for each
    group from the host file, creates a DataFrame containing the variables,
    then returns it.

    Parameters
    ----------
    hostgroups : list of str
        A list of hostgroups.
    private_data_dir : str
        The path to the Ansible private_data_dir, which is the directory
        containing the &#39;inventory&#39; folder. The default is the current folder.

    Returns
    -------
    df_vars : pd.DataFrame
        A DataFrame containing the group variables.

    Examples
    --------
    &gt;&gt;&gt; hostgroups = [&#39;group1&#39;, &#39;group2&#39;]
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; df_vars = ansible_create_vars_df(hostgroups, private_data_dir)
    &gt;&gt;&gt; print(df_vars)
    &#39;&#39;&#39;
    host_vars = dict()

    for g in hostgroups:
        group_vars = ansible_get_host_variables(g, private_data_dir)
        host_vars[g] = group_vars

    # Create a dictionary to store the variable data for each group
    df_data = dict()
    df_data[&#39;host_group&#39;] = list()

    # Iterate through the keys for each group in &#39;host_vars&#39;, adding it as a
    # key to &#39;df_data&#39;
    for key, value in host_vars.items():
        for k in value:
            if k != &#39;ansible_user&#39; and k != &#39;ansible_password&#39;:
                df_data[k] = list()

    # Iterate through &#39;host_vars&#39;, populating &#39;df_data&#39;
    for key, value in host_vars.items():
        df_data[&#39;host_group&#39;].append(key)
        for item in df_data:
            if item != &#39;host_group&#39;:
                result = value.get(item)
                df_data[item].append(result)

    df_vars = pd.DataFrame.from_dict(df_data)

    df_vars = df_vars.set_index(&#39;host_group&#39;)

    return df_vars</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_get_all_host_variables"><code class="name flex">
<span>def <span class="ident">ansible_get_all_host_variables</span></span>(<span>private_data_dir: str) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Ansible variables for all hostgroups in the inventory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>private_data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Ansible private_data_dir. This is the directory
containing the 'inventory' folder. The default is the current folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>groups_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>The Ansible variables for all host groups. The keys are host group
names and the values are the corresponding Ansible variables.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; private_data_dir = '/path/to/private/data/dir'
&gt;&gt;&gt; groups_vars = ansible_get_all_host_variables(private_data_dir)
&gt;&gt;&gt; print(groups_vars)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_get_all_host_variables(private_data_dir: str) -&gt; Dict[str, str]:
    &#39;&#39;&#39;
    Get the Ansible variables for all hostgroups in the inventory.

    Parameters
    ----------
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the directory
        containing the &#39;inventory&#39; folder. The default is the current folder.

    Returns
    -------
    groups_vars : dict
        The Ansible variables for all host groups. The keys are host group
        names and the values are the corresponding Ansible variables.

    Examples
    --------
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; groups_vars = ansible_get_all_host_variables(private_data_dir)
    &gt;&gt;&gt; print(groups_vars)
    &#39;&#39;&#39;
    # Read the contents of the playbook into a dictionary
    with open(f&#39;{private_data_dir}/inventory/hosts&#39;) as f:
        groups_vars = yaml.load(f, Loader=yaml.FullLoader)
    return groups_vars</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_get_all_hostgroup_os"><code class="name flex">
<span>def <span class="ident">ansible_get_all_hostgroup_os</span></span>(<span>private_data_dir: str) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Ansible OS for every hostgroup.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>private_data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Ansible private_data_dir. This is the directory
containing the 'inventory' folder. The default is the current folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>groups_os</code></strong> :&ensp;<code>dict</code></dt>
<dd>The Ansible OS for all host groups. The keys are host group names and
the values are the corresponding Ansible OS.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; private_data_dir = '/path/to/private/data/dir'
&gt;&gt;&gt; groups_os = ansible_get_all_hostgroup_os(private_data_dir)
&gt;&gt;&gt; print(groups_os)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_get_all_hostgroup_os(private_data_dir: str) -&gt; Dict[str, str]:
    &#39;&#39;&#39;
    Get the Ansible OS for every hostgroup.

    Parameters
    ----------
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the directory
        containing the &#39;inventory&#39; folder. The default is the current folder.

    Returns
    -------
    groups_os : dict
        The Ansible OS for all host groups. The keys are host group names and
        the values are the corresponding Ansible OS.

    Examples
    --------
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; groups_os = ansible_get_all_hostgroup_os(private_data_dir)
    &gt;&gt;&gt; print(groups_os)
    &#39;&#39;&#39;
    # Get all group variables
    groups_vars = ansible_get_all_host_variables(private_data_dir)

    groups_os = dict()

    for key, value in groups_vars.items():
        group_vars = value.get(&#39;vars&#39;)
        if group_vars and group_vars.get(&#39;ansible_network_os&#39;):
            groups_os[key] = value[&#39;vars&#39;][&#39;ansible_network_os&#39;]

    return groups_os</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_get_host_variables"><code class="name flex">
<span>def <span class="ident">ansible_get_host_variables</span></span>(<span>host_group: str, private_data_dir: str) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the variables for a host or host group in the hosts file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>host_group</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the host group.</dd>
<dt><strong><code>private_data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Ansible private_data_dir. This is the path that
the 'inventory' folder is in. The default is the current folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>group_vars</code></strong> :&ensp;<code>dict</code></dt>
<dd>The host group variables.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; host_group = '&lt;host_group&gt;'
&gt;&gt;&gt; private_data_dir = '/path/to/private/data/dir'
&gt;&gt;&gt; group_vars = ansible_get_host_variables(host_group, private_data_dir)
&gt;&gt;&gt; print(group_vars)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_get_host_variables(host_group: str, private_data_dir: str) -&gt; Dict:
    &#39;&#39;&#39;
    Get the variables for a host or host group in the hosts file.

    Parameters
    ----------
    host_group : str
        The name of the host group.
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the path that
        the &#39;inventory&#39; folder is in. The default is the current folder.

    Returns
    -------
    group_vars : dict
        The host group variables.

    Examples
    --------
    &gt;&gt;&gt; host_group = &#39;&lt;host_group&gt;&#39;
    &gt;&gt;&gt; private_data_dir = &#39;/path/to/private/data/dir&#39;
    &gt;&gt;&gt; group_vars = ansible_get_host_variables(host_group, private_data_dir)
    &gt;&gt;&gt; print(group_vars)
    &#39;&#39;&#39;
    # Read the contents of the playbook into a dictionary
    with open(f&#39;{private_data_dir}/inventory/hosts&#39;) as f:
        hosts = yaml.load(f, Loader=yaml.FullLoader)

    group_vars = hosts[host_group][&#39;vars&#39;]

    return group_vars</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_get_hostgroup"><code class="name flex">
<span>def <span class="ident">ansible_get_hostgroup</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Ansible hostgroup.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hostgroup</code></strong> :&ensp;<code>str</code></dt>
<dd>The Ansible hostgroup.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; hostgroup = ansible_get_hostgroup()
&gt;&gt;&gt; print(hostgroup)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_get_hostgroup() -&gt; str:
    &#39;&#39;&#39;
    Get the Ansible hostgroup.

    Returns
    -------
    hostgroup : str
        The Ansible hostgroup.

    Examples
    --------
    &gt;&gt;&gt; hostgroup = ansible_get_hostgroup()
    &gt;&gt;&gt; print(hostgroup)
    &#39;&#39;&#39;

    host_group = input(&#39;Enter the name of the host group in the hosts file: &#39;)
    return host_group</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_get_hostgroup_devices"><code class="name flex">
<span>def <span class="ident">ansible_get_hostgroup_devices</span></span>(<span>hostgroup: str, host_files: List[str], quiet: bool = True) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the devices inside an Ansible inventory hostgroup.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostgroup</code></strong> :&ensp;<code>str</code></dt>
<dd>The Ansible hostgroup.</dd>
<dt><strong><code>host_files</code></strong> :&ensp;<code>list</code></dt>
<dd>The path to one or more Ansible host files (e.g., ['inventory/hosts']).</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to output the entire graph. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>devices</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of devices in the hostgroup.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; hostgroup = '&lt;hostgroup&gt;'
&gt;&gt;&gt; host_files = ['inventory/hosts']
&gt;&gt;&gt; devices = ansible_get_hostgroup_devices(hostgroup, host_files)
&gt;&gt;&gt; print(devices)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_get_hostgroup_devices(hostgroup: str,
                                  host_files: List[str],
                                  quiet: bool = True) -&gt; List[str]:
    &#39;&#39;&#39;
    Get the devices inside an Ansible inventory hostgroup.

    Parameters
    ----------
    hostgroup : str
        The Ansible hostgroup.
    host_files : list
        The path to one or more Ansible host files (e.g., [&#39;inventory/hosts&#39;]).
    quiet : bool, optional
        Whether to output the entire graph. Defaults to True.

    Returns
    -------
    devices : list
        A list of devices in the hostgroup.

    Examples
    --------
    &gt;&gt;&gt; hostgroup = &#39;&lt;hostgroup&gt;&#39;
    &gt;&gt;&gt; host_files = [&#39;inventory/hosts&#39;]
    &gt;&gt;&gt; devices = ansible_get_hostgroup_devices(hostgroup, host_files)
    &gt;&gt;&gt; print(devices)
    &#39;&#39;&#39;
    graph = ansible_runner.interface.get_inventory(&#39;graph&#39;,
                                                   host_files,
                                                   quiet=True)
    graph = str(graph)
    for item in graph.split(&#39;@&#39;):
        if hostgroup in item:
            item = item.split(&#39;:&#39;)[-1]
            item = item.split(&#39;|--&#39;)[1:-1]
            devices = [i.split(&#39;\\&#39;)[0] for i in item]
            break
    return devices</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_get_hostgroups"><code class="name flex">
<span>def <span class="ident">ansible_get_hostgroups</span></span>(<span>inventories: List[str], quiet: bool = True) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the devices inside an Ansible inventory hostgroup.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>inventories</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The path to one or more Ansible host files (e.g.,
['inventory/hosts']).</dd>
<dt><strong><code>quiet</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to output the entire graph. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>devices</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of devices in the hostgroup.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_get_hostgroups(inventories: List[str],
                           quiet: bool = True) -&gt; List[str]:
    &#39;&#39;&#39;
    Gets the devices inside an Ansible inventory hostgroup.

    Parameters
    ----------
    inventories : list of str
        The path to one or more Ansible host files (e.g.,
        [&#39;inventory/hosts&#39;]).
    quiet : bool, optional
        Whether to output the entire graph. Defaults to True.

    Returns
    -------
    devices : list of str
        A list of devices in the hostgroup.
    &#39;&#39;&#39;
    graph = ansible_runner.interface.get_inventory(&#39;graph&#39;,
                                                   inventories,
                                                   quiet=True)
    graph = str(graph).strip(&#34;(&#39;&#34;)
    # graph = list(filter(None, graph))
    hostgroups = list()
    graph = list(filter(None, graph.split(&#39;@&#39;)))
    # TODO: Write a better parser
    for item in graph:
        hostgroup = item.split(&#39;:&#39;)[0]
        hostgroups.append(hostgroup)
    return hostgroups</code></pre>
</details>
</dd>
<dt id="helpers.helpers.ansible_group_hostgroups_by_os"><code class="name flex">
<span>def <span class="ident">ansible_group_hostgroups_by_os</span></span>(<span>private_data_dir: str) ‑> Dict[str, List[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the ansible_network_os for all hostgroups that have defined it in the
variables, then organizes the hostgroups by os.</p>
<p>For example:</p>
<p>groups_os['cisco.asa.asa'] = ['asa_group_1']
groups_os['cisco.nxos.nxos'] = ['nxos_group_1', 'nxos_group_2']</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>private_data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Ansible private_data_dir. This is the path that the
'inventory' folder is in. The default is the current folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>hostgroup_by_os</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the hostgroups, grouped by OS.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; private_data_dir = '&lt;private_data_dir&gt;'
&gt;&gt;&gt; hostgroup_by_os = ansible_group_hostgroups_by_os(private_data_dir)
&gt;&gt;&gt; print(hostgroup_by_os)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ansible_group_hostgroups_by_os(private_data_dir: str) \
        -&gt; Dict[str, List[str]]:
    &#39;&#39;&#39;
    Finds the ansible_network_os for all hostgroups that have defined it in the
    variables, then organizes the hostgroups by os.

    For example:

    groups_os[&#39;cisco.asa.asa&#39;] = [&#39;asa_group_1&#39;]
    groups_os[&#39;cisco.nxos.nxos&#39;] = [&#39;nxos_group_1&#39;, &#39;nxos_group_2&#39;]

    Parameters
    ----------
    private_data_dir : str
        The path to the Ansible private_data_dir. This is the path that the
        &#39;inventory&#39; folder is in. The default is the current folder.

    Returns
    -------
    hostgroup_by_os : dict
        A dictionary containing the hostgroups, grouped by OS.

    Examples
    --------
    &gt;&gt;&gt; private_data_dir = &#39;&lt;private_data_dir&gt;&#39;
    &gt;&gt;&gt; hostgroup_by_os = ansible_group_hostgroups_by_os(private_data_dir)
    &gt;&gt;&gt; print(hostgroup_by_os)
    &#39;&#39;&#39;
    # Get the OS for all Ansible hostgroups
    groups_os = ansible_get_all_hostgroup_os(private_data_dir)

    # Extract the OS and create dict for all hostgroups that have defined it
    groups_by_os = dict()
    for key, value in groups_os.items():
        if not groups_by_os.get(value):
            groups_by_os[value] = list()
        groups_by_os[value].append(key)
    return groups_by_os</code></pre>
</details>
</dd>
<dt id="helpers.helpers.check_dir_existence"><code class="name flex">
<span>def <span class="ident">check_dir_existence</span></span>(<span>dir_path: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check whether a directory exists.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dir_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>exists</code></strong> :&ensp;<code>bool</code></dt>
<dd>A boolean to indicate whether the directory exists.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; dir_path = '/path/to/directory'
&gt;&gt;&gt; exists = check_dir_existence(dir_path)
&gt;&gt;&gt; print(exists)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_dir_existence(dir_path: str) -&gt; bool:
    &#39;&#39;&#39;
    Check whether a directory exists.

    Parameters
    ----------
    dir_path : str
        The path to the directory.

    Returns
    -------
    exists : bool
        A boolean to indicate whether the directory exists.

    Examples
    --------
    &gt;&gt;&gt; dir_path = &#39;/path/to/directory&#39;
    &gt;&gt;&gt; exists = check_dir_existence(dir_path)
    &gt;&gt;&gt; print(exists)
    &#39;&#39;&#39;
    exists = False
    if os.path.exists(dir_path):
        exists = True
    return exists</code></pre>
</details>
</dd>
<dt id="helpers.helpers.connect_to_db"><code class="name flex">
<span>def <span class="ident">connect_to_db</span></span>(<span>db: str) ‑> sqlite3.Connection</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a connection to the sqlite database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the database</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>con</code></strong> :&ensp;<code>sl.Connection</code></dt>
<dd>Connection to the database</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect_to_db(db: str) -&gt; sl.Connection:
    &#39;&#39;&#39;
    Opens a connection to the sqlite database.

    Parameters
    ----------
    db : str
        Path to the database

    Returns
    -------
    con : sl.Connection
        Connection to the database
    &#39;&#39;&#39;
    try:
        con = sl.connect(db)
    except Exception as e:
        if str(e) == &#39;unable to open database file&#39;:
            print(f&#39;Cannot connect to db &#34;{db}&#34;. Does directory exist?&#39;)
            sys.exit()
        else:
            print(f&#39;Caught exception &#34;{str(e)}&#34;&#39;)
            sys.exit()
    return con</code></pre>
</details>
</dd>
<dt id="helpers.helpers.convert_mask_to_cidr"><code class="name flex">
<span>def <span class="ident">convert_mask_to_cidr</span></span>(<span>netmask: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a subnet mask to CIDR notation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>netmask</code></strong> :&ensp;<code>str</code></dt>
<dd>A subnet mask in xxx.xxx.xxx.xxx format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cidr</code></strong> :&ensp;<code>str</code></dt>
<dd>The number of bits in the subnet mask (CIDR).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; netmask = '255.255.255.0'
&gt;&gt;&gt; cidr = convert_mask_to_cidr(netmask)
&gt;&gt;&gt; print(cidr)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_mask_to_cidr(netmask: str) -&gt; str:
    &#39;&#39;&#39;
    Convert a subnet mask to CIDR notation.

    Parameters
    ----------
    netmask : str
        A subnet mask in xxx.xxx.xxx.xxx format.

    Returns
    -------
    cidr : str
        The number of bits in the subnet mask (CIDR).

    Examples
    --------
    &gt;&gt;&gt; netmask = &#39;255.255.255.0&#39;
    &gt;&gt;&gt; cidr = convert_mask_to_cidr(netmask)
    &gt;&gt;&gt; print(cidr)
    &#39;&#39;&#39;
    cidr = sum(bin(int(x)).count(&#39;1&#39;) for x in netmask.split(&#39;.&#39;))
    return cidr</code></pre>
</details>
</dd>
<dt id="helpers.helpers.create_dir"><code class="name flex">
<span>def <span class="ident">create_dir</span></span>(<span>dir_path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a directory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dir_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the directory.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; dir_path = '/path/to/new/directory'
&gt;&gt;&gt; create_dir(dir_path)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_dir(dir_path: str) -&gt; None:
    &#39;&#39;&#39;
    Create a directory.

    Parameters
    ----------
    dir_path : str
        The path to the directory.

    Returns
    -------
    None

    Examples
    --------
    &gt;&gt;&gt; dir_path = &#39;/path/to/new/directory&#39;
    &gt;&gt;&gt; create_dir(dir_path)
    &#39;&#39;&#39;
    os.mkdir(dir_path)</code></pre>
</details>
</dd>
<dt id="helpers.helpers.create_sqlite_regexp_function"><code class="name flex">
<span>def <span class="ident">create_sqlite_regexp_function</span></span>(<span>conn: sqlite3.Connection) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a SQLite3 function that allows REGEXP queries. More details can be
found at the following URLs:
- 'https://tinyurl.com/mwxz2dn8'
- 'https://tinyurl.com/ye285mnj'</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>conn</code></strong> :&ensp;<code>sqlite3.Connection</code></dt>
<dd>An object for connecting to the sqlite3 database.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_sqlite_regexp_function(conn: sl.Connection) -&gt; None:
    &#39;&#39;&#39;
    Creates a SQLite3 function that allows REGEXP queries. More details can be
    found at the following URLs:
    - &#39;https://tinyurl.com/mwxz2dn8&#39;
    - &#39;https://tinyurl.com/ye285mnj&#39;

    Parameters
    ----------
    conn : sqlite3.Connection
        An object for connecting to the sqlite3 database.

    Returns
    -------
    None
    &#39;&#39;&#39;
    # This function is credited to Stack Overflow user &#39;unutbu&#39;:
    # - https://tinyurl.com/ye285mnj
    def regexp(expr, item):
        reg = re.compile(expr)
        return reg.search(item) is not None
    conn.create_function(&#39;REGEXP&#39;, 2, regexp)</code></pre>
</details>
</dd>
<dt id="helpers.helpers.define_collectors"><code class="name flex">
<span>def <span class="ident">define_collectors</span></span>(<span>hostgroup: str) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a list of collectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hostgroup</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the hostgroup.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>available</code></strong> :&ensp;<code>dict</code></dt>
<dd>The collectors supported by the hostgroup.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; hostgroup = '&lt;hostgroup&gt;'
&gt;&gt;&gt; available = define_collectors(hostgroup)
&gt;&gt;&gt; print(available)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_collectors(hostgroup: str) -&gt; Dict[str, Any]:
    &#39;&#39;&#39;
    Creates a list of collectors.

    Parameters
    ----------
    hostgroup : str
        The name of the hostgroup.

    Returns
    -------
    available : dict
        The collectors supported by the hostgroup.

    Examples
    --------
    &gt;&gt;&gt; hostgroup = &#39;&lt;hostgroup&gt;&#39;
    &gt;&gt;&gt; available = define_collectors(hostgroup)
    &gt;&gt;&gt; print(available)
    &#39;&#39;&#39;
    # TODO: Find a more dynamic way to create this dictionary
    collectors = {&#39;arp_table&#39;: [&#39;bigip&#39;,
                                &#39;cisco.ios.ios&#39;,
                                &#39;cisco.nxos.nxos&#39;,
                                &#39;paloaltonetworks.panos&#39;],
                  &#39;cam_table&#39;: [&#39;cisco.ios.ios&#39;, &#39;cisco.nxos.nxos&#39;],
                  &#39;config&#39;: [&#39;cisco.ios.ios&#39;],
                  &#39;devices_inventory&#39;: [&#39;cisco.dnac&#39;],
                  &#39;devices_modules&#39;: [&#39;cisco.dnac&#39;],
                  &#39;ncm_serial_numbers&#39;: [&#39;solarwinds&#39;],
                  &#39;network_appliance_vlans&#39;: [&#39;meraki&#39;],
                  &#39;npm_containers&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_group_members&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_group_names&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_ids&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_ips&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_machine_types&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_os_versions&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_node_vendors&#39;: [&#39;solarwinds&#39;],
                  &#39;npm_nodes&#39;: [&#39;solarwinds&#39;],
                  &#39;node_availability&#39;: [&#39;bigip&#39;],
                  &#39;pool_availability&#39;: [&#39;bigip&#39;],
                  &#39;pool_member_availability&#39;: [&#39;bigip&#39;],
                  &#39;pool_summary&#39;: [&#39;bigip&#39;],
                  &#39;self_ips&#39;: [&#39;bigip&#39;],
                  &#39;vip_availability&#39;: [&#39;bigip&#39;],
                  &#39;vip_destinations&#39;: [&#39;bigip&#39;],
                  #  &#39;vip_summary&#39;: [&#39;bigip&#39;],
                  &#39;vlans&#39;: [&#39;bigip&#39;,
                            &#39;cisco.ios.ios&#39;,
                            &#39;cisco.nxos.nxos&#39;,
                            &#39;infoblox_nios&#39;],
                  &#39;networks&#39;: [&#39;infoblox_nios&#39;],
                  &#39;network_containers&#39;: [&#39;infoblox_nios&#39;],
                  &#39;networks_parent_containers&#39;: [&#39;infoblox_nios&#39;],
                  &#39;vlan_ranges&#39;: [&#39;infoblox_nios&#39;],
                  &#39;interface_description&#39;: [&#39;bigip&#39;,
                                            &#39;cisco.ios.ios&#39;,
                                            &#39;cisco.nxos.nxos&#39;],
                  &#39;interface_ip_addresses&#39;: [&#39;cisco.asa.asa&#39;,
                                             &#39;cisco.ios.ios&#39;,
                                             &#39;cisco.nxos.nxos&#39;,
                                             &#39;paloaltonetworks.panos&#39;],
                  &#39;interface_status&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;interface_summary&#39;: [&#39;bigip&#39;, &#39;cisco.nxos.nxos&#39;],
                  &#39;inventory_nxos&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;network_clients&#39;: [&#39;meraki&#39;],
                  &#39;network_devices&#39;: [&#39;meraki&#39;],
                  &#39;network_device_statuses&#39;: [&#39;meraki&#39;],
                  &#39;organizations&#39;: [&#39;meraki&#39;],
                  &#39;org_devices&#39;: [&#39;meraki&#39;],
                  &#39;org_device_statuses&#39;: [&#39;meraki&#39;],
                  &#39;org_networks&#39;: [&#39;meraki&#39;],
                  &#39;switch_port_statuses&#39;: [&#39;meraki&#39;],
                  &#39;switch_lldp_neighbors&#39;: [&#39;meraki&#39;],
                  &#39;switch_port_usages&#39;: [&#39;meraki&#39;],
                  &#39;ipam_prefixes&#39;: [&#39;netbox&#39;],
                  &#39;all_interfaces&#39;: [&#39;paloaltonetworks.panos&#39;],
                  &#39;logical_interfaces&#39;: [&#39;paloaltonetworks.panos&#39;],
                  &#39;physical_interfaces&#39;: [&#39;paloaltonetworks.panos&#39;],
                  &#39;port_channel_data&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;vpc_state&#39;: [&#39;cisco.nxos.nxos&#39;],
                  &#39;vrfs&#39;: [&#39;cisco.ios.ios&#39;, &#39;cisco.nxos.nxos&#39;]}

    available = list()
    for key, value in collectors.items():
        if hostgroup in value:
            available.append(key)
    return available</code></pre>
</details>
</dd>
<dt id="helpers.helpers.define_supported_validation_tables"><code class="name flex">
<span>def <span class="ident">define_supported_validation_tables</span></span>(<span>) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of tables that are supported for validation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>supported_tables</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of supported tables.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; supported_tables = define_supported_validation_tables()
&gt;&gt;&gt; print(supported_tables)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_supported_validation_tables() -&gt; List[str]:
    &#39;&#39;&#39;
    Return a list of tables that are supported for validation.

    Returns
    -------
    supported_tables : list
        A list of supported tables.

    Examples
    --------
    &gt;&gt;&gt; supported_tables = define_supported_validation_tables()
    &gt;&gt;&gt; print(supported_tables)
    &#39;&#39;&#39;
    supported_tables = dict()

    supported_tables[&#39;MERAKI_ORG_DEVICE_STATUSES&#39;] = dict()
    supported_tables[&#39;MERAKI_ORG_DEVICE_STATUSES&#39;][&#39;status&#39;] = &#39;online&#39;

    supported_tables[&#39;BIGIP_POOL_AVAILABILITY&#39;] = dict()
    supported_tables[&#39;BIGIP_POOL_AVAILABILITY&#39;][&#39;availability&#39;] = &#39;available&#39;

    supported_tables[&#39;BIGIP_POOL_MEMBER_AVAILABILITY&#39;] = dict()
    supported_tables[&#39;BIGIP_POOL_MEMBER_AVAILABILITY&#39;][&#39;pool_member_state&#39;] = \
        &#39;available&#39;

    supported_tables[&#39;BIGIP_VIP_AVAILABILITY&#39;] = dict()
    supported_tables[&#39;BIGIP_VIP_AVAILABILITY&#39;][&#39;availability&#39;] = &#39;available&#39;

    return supported_tables</code></pre>
</details>
</dd>
<dt id="helpers.helpers.download_ouis"><code class="name flex">
<span>def <span class="ident">download_ouis</span></span>(<span>path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Downloads vendor OUIs from <a href="https://standards-oui.ieee.org/.">https://standards-oui.ieee.org/.</a></p>
<p>The results will be stored in a text file located at 'path'.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The full path to the filename to store the results.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileNotFoundError</code></dt>
<dd>If the directory in the path does not exist.</dd>
<dt><code>IsADirectoryError</code></dt>
<dd>If a filename was not included in 'path'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; path = '/tmp/ouis.txt'
&gt;&gt;&gt; download_ouis(path)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_ouis(path: str) -&gt; None:
    &#39;&#39;&#39;
    Downloads vendor OUIs from https://standards-oui.ieee.org/.

    The results will be stored in a text file located at &#39;path&#39;.

    Parameters
    ----------
    path : str
        The full path to the filename to store the results.

    Raises
    ----------
    FileNotFoundError
        If the directory in the path does not exist.
    IsADirectoryError
        If a filename was not included in &#39;path&#39;.

    Examples
    ----------
    &gt;&gt;&gt; path = &#39;/tmp/ouis.txt&#39;
    &gt;&gt;&gt; download_ouis(path)
    &#39;&#39;&#39;
    url = &#39;https://standards-oui.ieee.org/&#39;
    response = requests.get(url, stream=True)
    with open(path, &#39;wb&#39;) as txt:
        for chunk in response.iter_content(chunk_size=1024):
            if chunk:
                txt.write(chunk)</code></pre>
</details>
</dd>
<dt id="helpers.helpers.f5_create_authentication_token"><code class="name flex">
<span>def <span class="ident">f5_create_authentication_token</span></span>(<span>device: str, username: str, password: str, loginProviderName: str = 'tmos', verify: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an authentication token to use for F5 REST API calls.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>device</code></strong> :&ensp;<code>str</code></dt>
<dd>The device name or IP address.</dd>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's password.</dd>
<dt><strong><code>loginProviderName</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The value to use for 'loginProviderName'. Defaults to 'tmos'.
It should only need to be changed if F5 documentation or support
says it is necessary.</dd>
<dt><strong><code>verify</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to verify certs. Defaults to 'True'. Should only be set
to 'False' if it is a dev environment or the F5 is using
self-signed certificates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>token</code></strong> :&ensp;<code>str</code></dt>
<dd>The authentication token.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f5_create_authentication_token(device: str,
                                   username: str,
                                   password: str,
                                   loginProviderName: str = &#39;tmos&#39;,
                                   verify: bool = True) -&gt; str:
    &#39;&#39;&#39;
    Creates an authentication token to use for F5 REST API calls.

    Parameters
    ----------
    device : str
        The device name or IP address.
    username : str
        The user&#39;s username.
    password : str
        The user&#39;s password.
    loginProviderName : str, optional
        The value to use for &#39;loginProviderName&#39;. Defaults to &#39;tmos&#39;.
        It should only need to be changed if F5 documentation or support
        says it is necessary.
    verify : bool, optional
        Whether to verify certs. Defaults to &#39;True&#39;. Should only be set
        to &#39;False&#39; if it is a dev environment or the F5 is using
        self-signed certificates.

    Returns
    -------
    token : str
        The authentication token.
    &#39;&#39;&#39;
    # Create the URL used for creating the authentication token
    url = f&#39;{device}/mgmt/shared/authn/login&#39;

    # Request the token
    content = {&#39;username&#39;: username,
               &#39;password&#39;: password,
               &#39;loginProviderName&#39;: loginProviderName}
    response = requests.post(url, json=content, verify=verify)
    token = response.json()[&#39;token&#39;][&#39;token&#39;]

    # Sleep for 1.5 seconds. This is required due to F5 bug ID1108181
    # https://cdn.f5.com/product/bugtracker/ID1108181.html
    time.sleep(1.5)

    # Return the token
    return token</code></pre>
</details>
</dd>
<dt id="helpers.helpers.find_mac_vendors"><code class="name flex">
<span>def <span class="ident">find_mac_vendors</span></span>(<span>macs: List[str], nm_path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the vendor OUI for a list of MAC addresses.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>macs</code></strong> :&ensp;<code>list</code></dt>
<dd>A list containing the MAC addresses for which to find the OUIs.</dd>
<dt><strong><code>nm_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Net-Manage repository.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>A Pandas DataFrame containing two columns. The first is the MAC
address, and the second is the corresponding vendor.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>There is a Python library to do this, but it is quite slow.</p>
<p>It might seem inefficient to parse the OUIs from a text file on an
as-needed basis. However, testing found that the operation only takes
about 250ms, and the size of the resulting dataframe is only
approximately 500KB.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import os
&gt;&gt;&gt; macs = ['00:50:56:bd:52:79', 'c4:34:6b:b9:99:32']
&gt;&gt;&gt; home_dir = os.path.expanduser('~')
&gt;&gt;&gt; nm_path = f'{home_dir}/source/repos/InsightSSG/Net-Manage'
&gt;&gt;&gt; df = find_mac_vendors(macs, nm_path)
&gt;&gt;&gt; print(df.to_dict())
{'mac': {0: '00:50:56:bd:52:79', 1: 'c4:34:6b:b9:99:32'},
'vendor': {0: 'VMware, Inc.', 1: 'Hewlett Packard'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_mac_vendors(macs: List[str], nm_path: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Finds the vendor OUI for a list of MAC addresses.

    Parameters
    ----------
    macs : list
        A list containing the MAC addresses for which to find the OUIs.
    nm_path : str
        The path to the Net-Manage repository.

    Returns
    -------
    df : DataFrame
        A Pandas DataFrame containing two columns. The first is the MAC
        address, and the second is the corresponding vendor.

    Notes
    -----
    There is a Python library to do this, but it is quite slow.

    It might seem inefficient to parse the OUIs from a text file on an
    as-needed basis. However, testing found that the operation only takes
    about 250ms, and the size of the resulting dataframe is only
    approximately 500KB.

    Examples
    --------
    &gt;&gt;&gt; import os
    &gt;&gt;&gt; macs = [&#39;00:50:56:bd:52:79&#39;, &#39;c4:34:6b:b9:99:32&#39;]
    &gt;&gt;&gt; home_dir = os.path.expanduser(&#39;~&#39;)
    &gt;&gt;&gt; nm_path = f&#39;{home_dir}/source/repos/InsightSSG/Net-Manage&#39;
    &gt;&gt;&gt; df = find_mac_vendors(macs, nm_path)
    &gt;&gt;&gt; print(df.to_dict())
    {&#39;mac&#39;: {0: &#39;00:50:56:bd:52:79&#39;, 1: &#39;c4:34:6b:b9:99:32&#39;},
    &#39;vendor&#39;: {0: &#39;VMware, Inc.&#39;, 1: &#39;Hewlett Packard&#39;}}
    &#39;&#39;&#39;
    # Convert MAC addresses to base 16 by removing special characters.
    addresses = [&#39;&#39;.join(filter(str.isalnum, _)).upper() for _ in macs]

    # Create a list to store vendors
    vendors = list()

    # Check if the list of OUIs exists and/or needs to be updated.
    df_ouis = update_ouis(nm_path)

    # Search df_ouis for the vendor and add it to &#39;vendors&#39;.
    for address in addresses:
        vendor = df_ouis.loc[df_ouis[&#39;base&#39;] == address[:6]][&#39;vendor&#39;]
        if len(vendor) &gt;= 1:
            vendors.append(vendor.squeeze())
        else:
            vendors.append(&#39;unknown&#39;)

    # Create the dataframe.
    df = pd.DataFrame()
    df[&#39;mac&#39;] = macs
    df[&#39;vendor&#39;] = vendors

    return df</code></pre>
</details>
</dd>
<dt id="helpers.helpers.generate_subnet_details"><code class="name flex">
<span>def <span class="ident">generate_subnet_details</span></span>(<span>addresses: List[str], return_keys: List[str] = ['subnet', 'network_ip', 'broadcast_ip']) ‑> Dict[str, List[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the subnet, network, and broadcast IPs for a list of IPs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>addresses</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of IP addresses in the format {ip}/{subnet_mask_length}.</dd>
<dt><strong><code>return_keys</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of keys to return. Used for when a table has column names that
conflict with the default return_keys of 'subnet', 'network_ip', and
'broadcast_ip'. NOTE: The keys should be ordered so that element[0]
is for the 'subnet' column, element[1] for 'network_ip', and element[2]
for 'broadcast_ip'. Defaults to ['subnet','network_ip','broadcast_ip'].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary with three keys:
- 'subnet' : list of str
List of subnet in CIDR notation for each IP address in the input
list.
- 'network_ip' : list of str
List of network IP for each IP address in the input list.
- 'broadcast_ip' : list of str
List of broadcast IP for each IP address in the input list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_subnet_details(addresses: List[str],
                            return_keys: List[str] = [&#39;subnet&#39;,
                                                      &#39;network_ip&#39;,
                                                      &#39;broadcast_ip&#39;]) \
        -&gt; Dict[str, List[str]]:
    &#39;&#39;&#39;
    Generates the subnet, network, and broadcast IPs for a list of IPs.

    Parameters
    ----------
    addresses : list of str
        List of IP addresses in the format {ip}/{subnet_mask_length}.
    return_keys : list of str, optional
        List of keys to return. Used for when a table has column names that
        conflict with the default return_keys of &#39;subnet&#39;, &#39;network_ip&#39;, and
        &#39;broadcast_ip&#39;. NOTE: The keys should be ordered so that element[0]
        is for the &#39;subnet&#39; column, element[1] for &#39;network_ip&#39;, and element[2]
        for &#39;broadcast_ip&#39;. Defaults to [&#39;subnet&#39;,&#39;network_ip&#39;,&#39;broadcast_ip&#39;].

    Returns
    -------
    dict
        A dictionary with three keys:
        - &#39;subnet&#39; : list of str
            List of subnet in CIDR notation for each IP address in the input
            list.
        - &#39;network_ip&#39; : list of str
            List of network IP for each IP address in the input list.
        - &#39;broadcast_ip&#39; : list of str
            List of broadcast IP for each IP address in the input list.
    &#39;&#39;&#39;
    subnet = list()
    network_ip = list()
    broadcast_ip = list()

    for ip in addresses:
        ip_obj = ipaddress.ip_interface(ip)
        subnet.append(str(ip_obj.network))
        network_ip.append(str(ip_obj.network.network_address))
        brd = str(ipaddress.IPv4Address(int(ip_obj.network.broadcast_address)))
        broadcast_ip.append(brd)

    return {return_keys[0]: subnet,
            return_keys[1]: network_ip,
            return_keys[2]: broadcast_ip}</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_creds"><code class="name flex">
<span>def <span class="ident">get_creds</span></span>(<span>prompt: str = '') ‑> Tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the username and password to use for authentication.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A one-word description to use inside the prompt. For example, if
prompt == 'device', then the user would be presented with the full
prompt of 'Enter the username to use for device authentication.' If no
prompt is passed to the function, then the generic prompt will be used.
Defaults to ''.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username.</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The password.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_creds(prompt: str = &#39;&#39;) -&gt; Tuple[str, str]:
    &#39;&#39;&#39;
    Gets the username and password to use for authentication.

    Parameters
    ----------
    prompt : str, optional
        A one-word description to use inside the prompt. For example, if
        prompt == &#39;device&#39;, then the user would be presented with the full
        prompt of &#39;Enter the username to use for device authentication.&#39; If no
        prompt is passed to the function, then the generic prompt will be used.
        Defaults to &#39;&#39;.

    Returns
    -------
    username : str
        The username.
    password : str
        The password.
    &#39;&#39;&#39;
    username = get_username(prompt)
    password = get_password(prompt)
    return username, password</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_database_tables"><code class="name flex">
<span>def <span class="ident">get_database_tables</span></span>(<span>db_path: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all of the tables out of the database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tables</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of tables.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; db_path = '/path/to/database'
&gt;&gt;&gt; tables = get_database_tables(db_path)
&gt;&gt;&gt; print(tables)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_database_tables(db_path: str) -&gt; List[str]:
    &#39;&#39;&#39;
    Get all of the tables out of the database.

    Parameters
    ----------
    db_path : str
        The path to the database.

    Returns
    -------
    tables : list
        A list of tables.

    Examples
    --------
    &gt;&gt;&gt; db_path = &#39;/path/to/database&#39;
    &gt;&gt;&gt; tables = get_database_tables(db_path)
    &gt;&gt;&gt; print(tables)
    &#39;&#39;&#39;
    # sqlite_schema used to be named sqlite_master. This method tries the new
    # name but will fail back to the old name if the user is on an older
    # version
    name_old = &#39;master&#39;
    name_new = &#39;schema&#39;
    con = connect_to_db(db_path)
    query1 = f&#39;&#39;&#39;select name from sqlite_{name_new}
                 where type = &#34;table&#34; and name not like &#34;sqlite_%&#34;&#39;&#39;&#39;
    query2 = f&#39;&#39;&#39;select name from sqlite_{name_old}
                 where type = &#34;table&#34; and name not like &#34;sqlite_%&#34;&#39;&#39;&#39;
    try:
        df_tables = pd.read_sql(query1, con)
    except Exception:
        df_tables = pd.read_sql(query2, con)
    tables = df_tables[&#39;name&#39;].to_list()
    return tables</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_dir_timestamps"><code class="name flex">
<span>def <span class="ident">get_dir_timestamps</span></span>(<span>path: str) ‑> Dict[str, datetime.datetime]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the timestamp for all files and folders in a directory.</p>
<p>This function is not recursive.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to search.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>result</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary for each file or folder, where the key is the file or
folder name and the value is a datetime object containing the
timestamp.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; path = '/tmp/test/'
&gt;&gt;&gt; result = get_dir_timestamps(path)
&gt;&gt;&gt; pprint(result)
{'/tmp/test/test.txt': datetime.datetime(2023, 3, 7, 16, 15, 9),
'/tmp/test/test2.txt': datetime.datetime(2023, 3, 7, 16, 16, 4)}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dir_timestamps(path: str) -&gt; Dict[str, dt]:
    &#39;&#39;&#39;
    Gets the timestamp for all files and folders in a directory.

    This function is not recursive.

    Parameters
    ----------
    path : str
        The path to search.

    Returns
    -------
    result : dict
        A dictionary for each file or folder, where the key is the file or
        folder name and the value is a datetime object containing the
        timestamp.

    Examples
    --------
    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; path = &#39;/tmp/test/&#39;
    &gt;&gt;&gt; result = get_dir_timestamps(path)
    &gt;&gt;&gt; pprint(result)
    {&#39;/tmp/test/test.txt&#39;: datetime.datetime(2023, 3, 7, 16, 15, 9),
    &#39;/tmp/test/test2.txt&#39;: datetime.datetime(2023, 3, 7, 16, 16, 4)}
    &#39;&#39;&#39;
    files = glob.glob(f&#39;{path}/*&#39;)

    result = dict()
    for file in files:
        ts = time.ctime(os.path.getctime(file)).split()
        ts = &#39; &#39;.join([ts[1], ts[2], ts[-1], ts[3]])
        result[file] = dt.strptime(ts, &#34;%b %d %Y %H:%M:%S&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_first_last_timestamp"><code class="name flex">
<span>def <span class="ident">get_first_last_timestamp</span></span>(<span>db_path: str, table: str, col_name: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the first and last timestamp from a database table for each unique
entry in a column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>str</code></dt>
<dd>The table name.</dd>
<dt><strong><code>col_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The column name to search by (e.g., 'device', 'networkId', etc).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_stamps</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>A DataFrame containing the first and last timestamp for each unique
entry in the specified column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_first_last_timestamp(db_path: str,
                             table: str,
                             col_name: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets the first and last timestamp from a database table for each unique
    entry in a column.

    Parameters
    ----------
    db_path : str
        The path to the database.
    table : str
        The table name.
    col_name : str
        The column name to search by (e.g., &#39;device&#39;, &#39;networkId&#39;, etc).

    Returns
    -------
    df_stamps : DataFrame
        A DataFrame containing the first and last timestamp for each unique
        entry in the specified column.
    &#39;&#39;&#39;
    df_data = dict()
    df_data[col_name] = list()
    df_data[&#39;first_ts&#39;] = list()
    df_data[&#39;last_ts&#39;] = list()

    # Get the unique entries for col_name (usually a device name, MAC address,
    # etc). This is necessary since the first timestamp in the table won&#39;t
    # always have all the entries for that table (devices might be added or
    # removed, ARP tables might change, and so on)
    con = sl.connect(db_path)
    query = f&#39;select distinct {col_name} from {table}&#39;
    df_uniques = pd.read_sql(query, con)
    uniques = df_uniques[col_name].to_list()

    # Create a dictionary to store the first and last timestamps for col_name.
    # This will be used to create df_stamps
    # df_data = dict()

    query = f&#39;select distinct timestamp from {table}&#39;
    timestamps = pd.read_sql(query, con)[&#39;timestamp&#39;].to_list()

    for unique in uniques:
        stamps = list()
        for ts in timestamps:
            query = f&#39;&#39;&#39;select timestamp from {table}
                        where timestamp = &#34;{ts}&#34; and {col_name} = &#34;{unique}&#34;&#39;&#39;&#39;
            for item in pd.read_sql(query, con)[&#39;timestamp&#39;].to_list():
                stamps.append(item)
        df_data[col_name].append(unique)
        df_data[&#39;first_ts&#39;].append(stamps[0])
        df_data[&#39;last_ts&#39;].append(stamps[-1])

    # This is an alternative way to collect the first and last timestamps for
    # each col_name. It does not utilize an index (assuming the table has one),
    # but the speed was about the same. I am leaving it here to do more
    # testing with in the future.

    # for unique in uniques:
    #     query = f&#39;&#39;&#39;select distinct timestamp from {table}
    #                 where {col_name} = &#34;{unique}&#34;&#39;&#39;&#39;
    #     df_stamps = pd.read_sql(query, con)
    #     stamps = df_stamps[&#39;timestamp&#39;].to_list()
    #     df_data[col_name].append(unique)
    #     df_data[&#39;first_ts&#39;].append(stamps[0])
    #     df_data[&#39;last_ts&#39;].append(stamps[-1])
    con.close()

    df_stamps = pd.DataFrame.from_dict(df_data)

    return df_stamps</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_net_manage_path"><code class="name flex">
<span>def <span class="ident">get_net_manage_path</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the absolute path to the Net-Manage repository.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nm_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The absolute path to the Net-Manage repository.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_net_manage_path() -&gt; str:
    &#39;&#39;&#39;
    Set the absolute path to the Net-Manage repository.

    Returns
    -------
    nm_path : str
        The absolute path to the Net-Manage repository.
    &#39;&#39;&#39;
    nm_path = input(&#34;Enter the absolute path to the Net-Manage repository: &#34;)
    nm_path = os.path.expanduser(nm_path)
    return nm_path</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_password"><code class="name flex">
<span>def <span class="ident">get_password</span></span>(<span>prompt: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the password to use for authentication.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A one-word description to use inside the prompt. For example, if
prompt == 'device', then the user would be presented with the full
prompt of 'Enter the username to use for device authentication.' If
no prompt is passed to the function, then the generic prompt will be
used. Default is an empty string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>The password.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_password(prompt: str = &#39;&#39;) -&gt; str:
    &#39;&#39;&#39;
    Gets the password to use for authentication.

    Parameters
    ----------
    prompt : str, optional
        A one-word description to use inside the prompt. For example, if
        prompt == &#39;device&#39;, then the user would be presented with the full
        prompt of &#39;Enter the username to use for device authentication.&#39; If
        no prompt is passed to the function, then the generic prompt will be
        used. Default is an empty string.

    Returns
    -------
    password : str
        The password.
    &#39;&#39;&#39;
    # Create the full prompt
    if not prompt:
        f_prompt = &#39;Enter the password to use for authentication: &#39;
    else:
        f_prompt = f&#39;Enter the password to use for {prompt} authentication: &#39;

    # Get the user&#39;s password and have them type it twice for verification
    pass1 = str()
    pass2 = None
    while pass1 != pass2:
        pass1 = getpass(f_prompt)
        pass2 = getpass(&#39;Confirm your password: &#39;)
        if pass1 != pass2:
            print(&#39;Error: Passwords do not match.&#39;)
    password = pass1

    return password</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_tests_file"><code class="name flex">
<span>def <span class="ident">get_tests_file</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the absolute path to the Net-Manage repository.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>t_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The absolute path to the file containing tests to run.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tests_file() -&gt; str:
    &#39;&#39;&#39;
    Set the absolute path to the Net-Manage repository.

    Returns
    -------
    t_path : str
        The absolute path to the file containing tests to run.
    &#39;&#39;&#39;
    t_file = input(&#34;Enter the absolute path to the Net-Manage repository: &#34;)
    t_file = os.path.expanduser(t_file)
    return t_file</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_user_meraki_input"><code class="name flex">
<span>def <span class="ident">get_user_meraki_input</span></span>(<span>) ‑> Tuple[List[str], List[str], List[str], int, int, Union[int, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Gets and parses user input when they select collectors for Meraki
organizations.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>orgs</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of one or more organizations. Defaults to an empty list.</dd>
<dt><strong><code>networks</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of one or more networks. Defaults to an empty list.</dd>
<dt><strong><code>macs</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of one or more MAC addresses. Partial addresses are accepted.
Defaults to an empty list.</dd>
<dt><strong><code>timespan</code></strong> :&ensp;<code>int</code></dt>
<dd>The lookback timespan in seconds. Defaults to 1 day (86400 seconds).
If a user has an * between numbers, it will multiply them. It does not
perform any other calculation (addition, subtraction, etc).</dd>
<dt><strong><code>per_page</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of results to return per page. Defaults to 10. It is
recommended to leave it at 10, as increasing the number of results
can reduce performance. However, increasing it might be worth trying
when working with large datasets.</dd>
<dt><strong><code>total_pages</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>The total number of pages to return. If input is 'all', returns as
'all'. Otherwise, converts the input into an integer. Defaults to
'all'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_meraki_input() -&gt; Tuple[List[str],
                                     List[str],
                                     List[str],
                                     int,
                                     int,
                                     Union[int, str]]:
    &#39;&#39;&#39;
    Gets and parses user input when they select collectors for Meraki
    organizations.

    Returns
    -------
    orgs : list
        A list of one or more organizations. Defaults to an empty list.
    networks : list
        A list of one or more networks. Defaults to an empty list.
    macs : list
        A list of one or more MAC addresses. Partial addresses are accepted.
        Defaults to an empty list.
    timespan : int
        The lookback timespan in seconds. Defaults to 1 day (86400 seconds).
        If a user has an * between numbers, it will multiply them. It does not
        perform any other calculation (addition, subtraction, etc).
    per_page : int
        The number of results to return per page. Defaults to 10. It is
        recommended to leave it at 10, as increasing the number of results
        can reduce performance. However, increasing it might be worth trying
        when working with large datasets.
    total_pages : int or str
        The total number of pages to return. If input is &#39;all&#39;, returns as
        &#39;all&#39;. Otherwise, converts the input into an integer. Defaults to
        &#39;all&#39;.
    &#39;&#39;&#39;
    orgs = input(&#39;Enter a comma-delimited list of organizations to query: &#39;)\
        or list()
    if orgs:
        orgs = [_.strip() for _ in orgs.split(&#39;,&#39;)]

    networks = input(&#39;Enter a comma-delimited list of networks to query: &#39;)\
        or list()
    if networks:
        networks = [_.strip() for _ in networks.split(&#39;,&#39;)]

    macs = input(&#39;Enter a comma-delimited list of MAC addresses: &#39;) or list()
    if macs:
        macs = [_.strip() for _ in macs.split(&#39;,&#39;)]

    timespan = input(&#39;Enter the lookback timespan in seconds: &#39;) or &#39;86400&#39;
    timespan = np.prod([int(_) for _ in timespan.split(&#39;*&#39;)])

    per_page = int(input(&#39;Enter the number of results per page: &#39;) or 10)

    total_pages = input(&#39;Enter the total number of pages to return: &#39;) or &#39;all&#39;
    if total_pages[0].isdigit() or total_pages[0] == &#39;-&#39;:
        total_pages = int(total_pages)

    return orgs, networks, macs, timespan, per_page, total_pages</code></pre>
</details>
</dd>
<dt id="helpers.helpers.get_username"><code class="name flex">
<span>def <span class="ident">get_username</span></span>(<span>prompt: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the username to use for authentication.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prompt</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A one-word description to use inside the prompt. For example, if
prompt == 'device', then the user would be presented with the full
prompt of 'Enter the username to use for device authentication.' If
no prompt is passed to the function, then the generic prompt will be
used. Default is an empty string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>username</code></strong> :&ensp;<code>str</code></dt>
<dd>The username.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_username(prompt: str = &#39;&#39;) -&gt; str:
    &#39;&#39;&#39;
    Gets the username to use for authentication.

    Parameters
    ----------
    prompt : str, optional
        A one-word description to use inside the prompt. For example, if
        prompt == &#39;device&#39;, then the user would be presented with the full
        prompt of &#39;Enter the username to use for device authentication.&#39; If
        no prompt is passed to the function, then the generic prompt will be
        used. Default is an empty string.

    Returns
    -------
    username : str
        The username.
    &#39;&#39;&#39;
    # Create the full prompt
    if not prompt:
        f_prompt = &#39;Enter the username to use for authentication: &#39;
    else:
        f_prompt = f&#39;Enter the username to use for {prompt} authentication: &#39;

    # Get the user&#39;s username
    username = input(f_prompt)

    return username</code></pre>
</details>
</dd>
<dt id="helpers.helpers.meraki_check_api_enablement"><code class="name flex">
<span>def <span class="ident">meraki_check_api_enablement</span></span>(<span>db_path: str, org: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Queries the database to find if API access is enabled.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database to store results.</dd>
<dt><strong><code>org</code></strong> :&ensp;<code>str</code></dt>
<dd>The organization to check API access for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>enabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>A boolean indicating whether API access is enabled for the user's API
key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meraki_check_api_enablement(db_path: str, org: str) -&gt; bool:
    &#39;&#39;&#39;
    Queries the database to find if API access is enabled.

    Parameters
    ----------
    db_path : str
        The path to the database to store results.
    org : str
        The organization to check API access for.

    Returns
    -------
    enabled : bool
        A boolean indicating whether API access is enabled for the user&#39;s API
        key.
    &#39;&#39;&#39;
    # enabled = False

    query = [&#39;SELECT timestamp, api from MERAKI_ORGANIZATIONS&#39;,
             f&#39;WHERE id = &#34;{org}&#34;&#39;,
             &#39;ORDER BY timestamp DESC&#39;,
             &#39;limit 1&#39;]
    query = &#39; &#39;.join(query)

    con = sl.connect(db_path)
    result = pd.read_sql(query, con)
    con.close()
    return ast.literal_eval(result.iloc[0][&#39;api&#39;])[&#39;enabled&#39;]

    # if result[&#39;api&#39;].to_list()[0] == &#39;True&#39;:
    #     enabled = True

    # return enabled</code></pre>
</details>
</dd>
<dt id="helpers.helpers.meraki_get_api_key"><code class="name flex">
<span>def <span class="ident">meraki_get_api_key</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the Meraki API key.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>api_key</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's API key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meraki_get_api_key() -&gt; str:
    &#39;&#39;&#39;
    Gets the Meraki API key.

    Returns
    -------
    api_key : str
        The user&#39;s API key.
    &#39;&#39;&#39;
    api_key = getpass(&#39;Enter your Meraki API key: &#39;)
    return api_key</code></pre>
</details>
</dd>
<dt id="helpers.helpers.meraki_map_network_to_organization"><code class="name flex">
<span>def <span class="ident">meraki_map_network_to_organization</span></span>(<span>network: str, db_path: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the organization ID for a network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>network</code></strong> :&ensp;<code>str</code></dt>
<dd>A network ID.</dd>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>org_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The organization ID.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meraki_map_network_to_organization(network: str, db_path: str) -&gt; str:
    &#39;&#39;&#39;
    Gets the organization ID for a network.

    Parameters
    ----------
    network : str
        A network ID.
    db_path : str
        The path to the database.

    Returns
    -------
    org_id : str
        The organization ID.
    &#39;&#39;&#39;
    query = f&#39;&#39;&#39;SELECT distinct timestamp, organizationId
                FROM MERAKI_ORG_NETWORKS
                WHERE id = &#34;{network}&#34;
                ORDER BY timestamp desc
                LIMIT 1
             &#39;&#39;&#39;
    con = sl.connect(db_path)
    result = pd.read_sql(query, con)
    con.close()

    org_id = result[&#39;organizationId&#39;].to_list()[0]

    return org_id</code></pre>
</details>
</dd>
<dt id="helpers.helpers.meraki_parse_organizations"><code class="name flex">
<span>def <span class="ident">meraki_parse_organizations</span></span>(<span>db_path: str, orgs: list = None, table: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a list of organizations that are passed to certain Meraki
collectors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database to store results.</dd>
<dt><strong><code>orgs</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>One or more organization IDs. If none are specified, then the
networks for all orgs will be returned. Defaults to None.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The database table to query. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>organizations</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of organizations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meraki_parse_organizations(db_path: str,
                               orgs: list = None,
                               table: str = None) -&gt; list:
    &#39;&#39;&#39;
    Parses a list of organizations that are passed to certain Meraki
    collectors.

    Parameters
    ----------
    db_path : str
        The path to the database to store results.
    orgs : list, optional
        One or more organization IDs. If none are specified, then the
        networks for all orgs will be returned. Defaults to None.
    table : str, optional
        The database table to query. Defaults to None.

    Returns
    -------
    organizations : list
        A list of organizations.
    &#39;&#39;&#39;
    con = sl.connect(db_path)
    organizations = list()
    if orgs:
        for org in orgs:
            df_orgs = pd.read_sql(f&#39;select distinct id from {table} \
                where id = &#34;{org}&#34;&#39;, con)
            organizations.append(df_orgs[&#39;id&#39;].to_list().pop())
    else:
        df_orgs = pd.read_sql(f&#39;select distinct id from {table}&#39;, con)
        for org in df_orgs[&#39;id&#39;].to_list():
            organizations.append(org)
    con.close()

    return organizations</code></pre>
</details>
</dd>
<dt id="helpers.helpers.move_cols_to_end"><code class="name flex">
<span>def <span class="ident">move_cols_to_end</span></span>(<span>df: pandas.core.frame.DataFrame, cols: List[str]) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Moves one or more columns on a dataframe to be the end. For example,
if the dataframe columns are ['A', 'C', 'B'], then this function can be
used to re-order them to ['A', 'B', 'C'].</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The Pandas dataframe to re-order.</dd>
<dt><strong><code>cols</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>A list of one or more columns to move. If more than one column is
specified, they will be added to the end in the order that is in
the list.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>The re-ordered DataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cols_to_end(df: pd.DataFrame, cols: List[str]) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Moves one or more columns on a dataframe to be the end. For example,
    if the dataframe columns are [&#39;A&#39;, &#39;C&#39;, &#39;B&#39;], then this function can be
    used to re-order them to [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;].

    Parameters
    ----------
    df : pd.DataFrame
        The Pandas dataframe to re-order.
    cols : list of str
        A list of one or more columns to move. If more than one column is
        specified, they will be added to the end in the order that is in
        the list.

    Returns
    -------
    pd.DataFrame
        The re-ordered DataFrame.
    &#39;&#39;&#39;
    for c in cols:
        df[c] = df.pop(c)
    return df</code></pre>
</details>
</dd>
<dt id="helpers.helpers.read_table"><code class="name flex">
<span>def <span class="ident">read_table</span></span>(<span>db_path: str, table: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Reads all columns for the latest timestamp from a database table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The full path to the database.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>str</code></dt>
<dd>The table name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A Pandas dataframe containing the data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_table(db_path: str, table: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Reads all columns for the latest timestamp from a database table.

    Parameters
    ----------
    db_path : str
        The full path to the database.
    table : str
        The table name.

    Returns
    -------
    df : pd.DataFrame
        A Pandas dataframe containing the data.
    &#39;&#39;&#39;
    con = connect_to_db(db_path)
    df_ts = pd.read_sql(f&#39;select timestamp from {table} limit 1&#39;, con)
    ts = df_ts[&#39;timestamp&#39;].to_list()[-1]
    df = pd.read_sql(f&#39;select * from {table} where timestamp = &#34;{ts}&#34;&#39;, con)
    con.close()
    return df</code></pre>
</details>
</dd>
<dt id="helpers.helpers.set_db_timestamp"><code class="name flex">
<span>def <span class="ident">set_db_timestamp</span></span>(<span>) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a timestamp in the form the database expects.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>str</code></dt>
<dd>A timestamp in the YYYY-MM-DD_hhmm format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_db_timestamp() -&gt; str:
    &#39;&#39;&#39;
    Sets a timestamp in the form the database expects.

    Returns
    -------
    timestamp : str
        A timestamp in the YYYY-MM-DD_hhmm format.
    &#39;&#39;&#39;
    timestamp = dt.now()
    timestamp = timestamp.strftime(&#39;%Y-%m-%d_%H%M&#39;)
    return timestamp</code></pre>
</details>
</dd>
<dt id="helpers.helpers.set_dependencies"><code class="name flex">
<span>def <span class="ident">set_dependencies</span></span>(<span>selected: List[str]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that dependent collectors are added to the selection. For example,
collecting 'f5_vip_destinations' requires collecting 'f5_vip_availability'.
If a user has selected the former without selecting the latter, then this
function adds the latter (in the proper order) to the selection.</p>
<p>TODO: Currently, all dependencies are within the same hostgroup. By that I
mean, F5 collectors are dependent on other F5 collectors, Meraki
collectors are dependent on other Meraki collectors, and so on.
It is possible that at some point collectors will be dependent on
hostgroups that the user did not select. If that happens, this
function will need to be modified accordingly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selected</code></strong> :&ensp;<code>list</code></dt>
<dd>The list of selected collectors.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>selected</code></strong> :&ensp;<code>list</code></dt>
<dd>The updated list of selected collectors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dependencies(selected: List[str]) -&gt; List[str]:
    &#39;&#39;&#39;
    Ensures that dependent collectors are added to the selection. For example,
    collecting &#39;f5_vip_destinations&#39; requires collecting &#39;f5_vip_availability&#39;.
    If a user has selected the former without selecting the latter, then this
    function adds the latter (in the proper order) to the selection.

    TODO: Currently, all dependencies are within the same hostgroup. By that I
          mean, F5 collectors are dependent on other F5 collectors, Meraki
          collectors are dependent on other Meraki collectors, and so on.
          It is possible that at some point collectors will be dependent on
          hostgroups that the user did not select. If that happens, this
          function will need to be modified accordingly.

    Parameters
    ----------
    selected : list
        The list of selected collectors.

    Returns
    -------
    selected : list
        The updated list of selected collectors.
    &#39;&#39;&#39;
    s = selected
    if &#39;devices_modules&#39; in s:
        if &#39;devices_inventory&#39; in s:
            pos = s.index(&#39;devices_inventory&#39;)
            del s[pos]
        s.insert(0, &#39;devices_inventory&#39;)

    if &#39;interface_summary&#39; in s:
        pos = s.index(&#39;interface_summary&#39;)
        if &#39;cam_table&#39; not in s:
            s.insert(pos, &#39;cam_table&#39;)
        if &#39;interface_description&#39; not in s:
            s.insert(pos, &#39;interface_description&#39;)
        if &#39;interface_status&#39; not in s:
            s.insert(pos, &#39;interface_status&#39;)
    if &#39;get_device_statuses&#39; in s:
        pos1 = s.index(&#39;get_device_statuses&#39;)
        if &#39;get_organizations&#39; in s:
            pos2 = s.index(&#39;get_organizations&#39;)
            if pos2 &gt; pos1:
                del s[pos2]
                s.insert(pos1, &#39;get_organizations&#39;)
        else:
            s.insert(pos1, &#39;get_organizations&#39;)

    if &#39;interface_summary&#39; in s:
        if &#39;cam_table&#39; in s:
            pos = s.index(&#39;cam_table&#39;)
            del s[pos]
        s.insert(0, &#39;cam_table&#39;)

    if &#39;vip_destinations&#39; in s:
        if &#39;vip_availability&#39; in s:
            pos = s.index(&#39;vip_availability&#39;)
            del s[pos]
        s.insert(0, &#39;vip_availability&#39;)

    if &#39;infoblox_get_networks_parent_containers&#39; in s:
        if &#39;infoblox_get_networks&#39; in s:
            pos = s.index(&#39;infoblox_get_networks&#39;)
            del s[pos]
        pos = s.insert(0, &#39;infoblox_get_networks&#39;)
        if &#39;infoblox_get_network_containers&#39; in s:
            pos = s.index(&#39;infoblox_get_network_containers&#39;)
            del s[pos]
        pos = s.insert(0, &#39;infoblox_get_network_containers&#39;)

    if &#39;device_statuses&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;network_appliance_vlans&#39; in s:
        if &#39;org_networks&#39; in s:
            pos = s.index(&#39;org_networks&#39;)
            del s[pos]
        s.insert(0, &#39;org_networks&#39;)

    if &#39;network_device_statuses&#39; in s:
        if &#39;org_device_statuses&#39; in s:
            pos = s.index(&#39;org_device_statuses&#39;)
            del s[pos]
        s.insert(0, &#39;org_device_statuses&#39;)

    if &#39;network_devices&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;org_devices&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;org_device_statuses&#39; in s:
        if &#39;org_networks&#39; in s:
            pos = s.index(&#39;org_networks&#39;)
            del s[pos]
        s.insert(0, &#39;org_networks&#39;)

    if &#39;org_networks&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;switch_lldp_neighbors&#39; in s:
        dependencies = [&#39;switch_port_statuses&#39;]
        for d in dependencies:
            if d in s:
                pos = s.index(d)
                del s[pos]
        for d in dependencies:
            s.insert(0, d)

    if &#39;switch_port_usages&#39; in s:
        if &#39;switch_port_statuses&#39; in s:
            pos = s.index(&#39;switch_port_statuses&#39;)
            del s[pos]
        s.insert(0, &#39;switch_port_statuses&#39;)

    if &#39;switch_port_statuses&#39; in s:
        if &#39;org_devices&#39; in s:
            pos = s.index(&#39;org_devices&#39;)
            del s[pos]
        s.insert(0, &#39;org_devices&#39;)
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    if &#39;vpn_statuses&#39; in s:
        if &#39;organizations&#39; in s:
            pos = s.index(&#39;organizations&#39;)
            del s[pos]
        s.insert(0, &#39;organizations&#39;)

    # Remove duplicate collectors from &#39;s&#39;
    non_dups = list()
    for item in s:
        if item not in non_dups:
            non_dups.append(item)
    s = non_dups

    selected = s
    return s</code></pre>
</details>
</dd>
<dt id="helpers.helpers.set_filepath"><code class="name flex">
<span>def <span class="ident">set_filepath</span></span>(<span>filepath: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a filename with the date and time added to a path the user
provides. The function assumes the last "." in a filename is the extension.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>The base filepath. Do not include the date; that will be added
dynamically at runtime.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>The full path to the modified filename.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_filepath(filepath: str) -&gt; str:
    &#39;&#39;&#39;
    Creates a filename with the date and time added to a path the user
    provides. The function assumes the last &#34;.&#34; in a filename is the extension.

    Parameters
    ----------
    filepath : str
        The base filepath. Do not include the date; that will be added
        dynamically at runtime.

    Returns
    -------
    filepath : str
        The full path to the modified filename.
    &#39;&#39;&#39;
    # Convert &#39;~&#39; to the user&#39;s home folder
    if &#39;~&#39; in filepath:
        filepath = filepath.replace(&#39;~&#39;, os.path.expanduser(&#39;~&#39;))
    # Set the prefix in YYYY-MM-DD_HHmm format
    prefix = dt.now().strftime(&#34;%Y-%m-%d_%H%M&#34;)
    # Extract the base path to the filename
    filepath = filepath.split(&#39;/&#39;)
    filename = filepath[-1]
    if len(filepath) &gt; 2:
        filepath = &#39;/&#39;.join(filepath[:-1])
    else:
        filepath = filepath[0]
    # Extract the filename and extension from &#39;filepath&#39;
    filename = filename.split(&#39;.&#39;)
    extension = filename[-1]
    if len(filename) &gt; 2:
        filename = &#39;.&#39;.join(filename[:-1])
    else:
        filename = filename[0]
    # Return the modified filename
    filepath = f&#39;{filepath}/{prefix}_{filename}.{extension}&#39;
    return filepath</code></pre>
</details>
</dd>
<dt id="helpers.helpers.set_vars"><code class="name flex">
<span>def <span class="ident">set_vars</span></span>(<span>) ‑> Tuple[str, str, List[str], str, str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Prompts the user for the required variables for running collectors and
validators. Several defaults are presented.</p>
<p>Note: The 'inventories' argument is a list of inventory files. Currently,
the function statically defines it as ['private_data_dir/inventory/hosts'].
If users want to use different file names or more than one file name,
that functionality can be added later.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>api_key</code></strong> :&ensp;<code>str</code></dt>
<dd>The api key.</dd>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database.</dd>
<dt><strong><code>inventories</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>The list of inventory files.</dd>
<dt><strong><code>nm_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the nm.</dd>
<dt><strong><code>out_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path for output.</dd>
<dt><strong><code>private_data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The private data directory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vars() -&gt; Tuple[str, str, List[str], str, str, str]:
    &#39;&#39;&#39;
    Prompts the user for the required variables for running collectors and
    validators. Several defaults are presented.

    Note: The &#39;inventories&#39; argument is a list of inventory files. Currently,
    the function statically defines it as [&#39;private_data_dir/inventory/hosts&#39;].
    If users want to use different file names or more than one file name,
    that functionality can be added later.

    Returns
    -------
    api_key : str
        The api key.
    db_path : str
        The path to the database.
    inventories : list of str
        The list of inventory files.
    nm_path : str
        The path to the nm.
    out_path : str
        The path for output.
    private_data_dir : str
        The private data directory.
    &#39;&#39;&#39;
    default_db = f&#39;{str(dt.now()).split()[0]}.db&#39;
    default_nm_path = &#39;~/source/repos/InsightSSG/Net-Manage/&#39;

    db = input(f&#39;Enter the name of the database: [{default_db}]&#39;)
    nm_path = input(f&#39;Enter path to Net-Manage repository [{default_nm_path}]&#39;)
    private_data_dir = input(&#39;Enter the path to the private data directory:&#39;)

    npm_server = input(&#39;Enter the URL of the Solarwinds NPM server:&#39;)
    npm_username = input(&#39;Enter the username for Solarwinds NPM:&#39;)
    npm_password = getpass(&#39;Enter the password for Solarwinds NPM:&#39;)

    default_out_path = f&#39;{private_data_dir}/output&#39;
    out_path = input(f&#39;Enter the path to store results: [{default_out_path}]&#39;)

    api_key = meraki_get_api_key()

    if not db:
        db = default_db
    if not nm_path:
        nm_path = default_nm_path
    if not out_path:
        out_path = default_out_path

    if not npm_server:
        npm_server = str()
    if not npm_username:
        npm_username = str()
    if not npm_password:
        npm_password = str()

    db = os.path.expanduser(db)
    nm_path = os.path.expanduser(nm_path)
    out_path = os.path.expanduser(out_path)
    private_data_dir = os.path.expanduser(private_data_dir)
    db_path = f&#39;{out_path}/{db}&#39;

    # TODO: Add support for a custom inventory file name
    # TODO: Add support for more than one inventory file (Ansible-Runner
    #       supports that, but I am not sure how common it is)
    inventories = [f&#39;{private_data_dir}/inventory/hosts&#39;]

    return api_key, db, db_path, inventories, npm_server, npm_username, \
        npm_password, nm_path, out_path, private_data_dir</code></pre>
</details>
</dd>
<dt id="helpers.helpers.sql_get_table_schema"><code class="name flex">
<span>def <span class="ident">sql_get_table_schema</span></span>(<span>db_path: str, table: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the schema of a table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>db_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the database.</dd>
<dt><strong><code>table</code></strong> :&ensp;<code>str</code></dt>
<dd>The table from which to get the schema.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_schema</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The table schema. If the table does not exist then an empty dataframe
will be returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sql_get_table_schema(db_path: str, table: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Gets the schema of a table.

    Parameters
    ----------
    db_path : str
        The path to the database.
    table : str
        The table from which to get the schema.

    Returns
    -------
    df_schema : pd.DataFrame
        The table schema. If the table does not exist then an empty dataframe
        will be returned.
    &#39;&#39;&#39;
    query = f&#39;pragma table_info(&#34;{table}&#34;)&#39;

    con = sl.connect(db_path)
    df_schema = pd.read_sql(query, con)

    return df_schema</code></pre>
</details>
</dd>
<dt id="helpers.helpers.suppress_extravars"><code class="name flex">
<span>def <span class="ident">suppress_extravars</span></span>(<span>extravars: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>ansible_runner.run stores extravars to a file named 'extravars' then saves
it to the local drive. The file is unencrypted, so any sensitive data, like
usernames and password, are stored in plain text.</p>
<p>People have complained about this for years. Finally, starting in version
2.x, the devs added the 'suppress_env_files' arg. This keeps extravars from
being stored locally.</p>
<p>The sole purpose of this function is to ensure that legacy Ansible-Runner
commands add that argument. <em>All ansible_runner.run args should be passed
to this function, no exceptions.</em></p>
<p>If they do not use extravars, then just pass an empty dict.
This will ensure the functions are secure if someone adds extravars to them
later.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>extravars</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the extravars. If your function does not use
it, then pass an empty dict instead.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>extravars</code></strong> :&ensp;<code>dict</code></dt>
<dd>'extravars' with the 'suppress_env_files' key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suppress_extravars(extravars: dict) -&gt; dict:
    &#39;&#39;&#39;
    ansible_runner.run stores extravars to a file named &#39;extravars&#39; then saves
    it to the local drive. The file is unencrypted, so any sensitive data, like
    usernames and password, are stored in plain text.

    People have complained about this for years. Finally, starting in version
    2.x, the devs added the &#39;suppress_env_files&#39; arg. This keeps extravars from
    being stored locally.

    The sole purpose of this function is to ensure that legacy Ansible-Runner
    commands add that argument. *All ansible_runner.run args should be passed
    to this function, no exceptions.*

    If they do not use extravars, then just pass an empty dict.
    This will ensure the functions are secure if someone adds extravars to them
    later.

    Parameters
    ----------
    extravars : dict
        A dictionary containing the extravars. If your function does not use
        it, then pass an empty dict instead.

    Returns
    -------
    extravars : dict
        &#39;extravars&#39; with the &#39;suppress_env_files&#39; key.
    &#39;&#39;&#39;
    # TODO: Finish this function. (Note: I thought about adding a check to
    #       manually delete any files in extravars at beginning and end of
    #       each run, but users might not want that.)</code></pre>
</details>
</dd>
<dt id="helpers.helpers.tabulate_df_head"><code class="name flex">
<span>def <span class="ident">tabulate_df_head</span></span>(<span>df: pandas.core.frame.DataFrame) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Print the first 5 rows of a DataFrame as a table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>The DataFrame to print.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>This function does not return anything, it simply prints the table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tabulate_df_head(df: pd.DataFrame) -&gt; None:
    &#39;&#39;&#39;
    Print the first 5 rows of a DataFrame as a table.

    Parameters
    ----------
    df : pandas.DataFrame
        The DataFrame to print.

    Returns
    -------
    None
        This function does not return anything, it simply prints the table.
    &#39;&#39;&#39;
    table_data = df.head().to_dict(&#39;records&#39;)

    print(tabulate(table_data, headers=&#39;keys&#39;, tablefmt=&#39;psql&#39;))</code></pre>
</details>
</dd>
<dt id="helpers.helpers.update_ouis"><code class="name flex">
<span>def <span class="ident">update_ouis</span></span>(<span>nm_path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Download or update vendor OUIs and save them to a file.</p>
<p>The data is pulled from <a href="https://standards-oui.ieee.org/">https://standards-oui.ieee.org/</a> and saved to a
text file named 'ouis.txt'. If 'ouis.txt' does not exist or is more
than one week old, then it will be downloaded.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nm_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Net-Manage repository.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>There is a Python library to do this, but it is quite slow.</p>
<p>It might seem inefficient to parse the OUIs from a text file on an
as-needed basis. However, testing found that the operation only takes
about 250ms, and the size of the resulting dataframe is only
approximately 500KB.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>A Pandas DataFrame containing two columns. The first is the MAC
address base in base16 format, and the second is the corresponding
vendor OUI.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = update_ouis(nm_path)
&gt;&gt;&gt; print(df[:2].to_dict())
{'mac_base': {0: '002272', 1: '00D0EF'},
'vendor_oui': {0: 'American Micro-Fuel Device Corp.', 1: 'IGT'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_ouis(nm_path: str) -&gt; pd.DataFrame:
    &#39;&#39;&#39;
    Download or update vendor OUIs and save them to a file.

    The data is pulled from https://standards-oui.ieee.org/ and saved to a
    text file named &#39;ouis.txt&#39;. If &#39;ouis.txt&#39; does not exist or is more
    than one week old, then it will be downloaded.

    Parameters
    ----------
    nm_path : str
        The path to the Net-Manage repository.

    Notes
    ----------
    There is a Python library to do this, but it is quite slow.

    It might seem inefficient to parse the OUIs from a text file on an
    as-needed basis. However, testing found that the operation only takes
    about 250ms, and the size of the resulting dataframe is only
    approximately 500KB.

    Returns
    ----------
    df : DataFrame
        A Pandas DataFrame containing two columns. The first is the MAC
        address base in base16 format, and the second is the corresponding
        vendor OUI.

    Examples
    ----------
    &gt;&gt;&gt; df = update_ouis(nm_path)
    &gt;&gt;&gt; print(df[:2].to_dict())
    {&#39;mac_base&#39;: {0: &#39;002272&#39;, 1: &#39;00D0EF&#39;},
    &#39;vendor_oui&#39;: {0: &#39;American Micro-Fuel Device Corp.&#39;, 1: &#39;IGT&#39;}}
    &#39;&#39;&#39;
    # Check if &#39;ouis.txt&#39; exists in &#39;nm_path&#39;, and, if so, get the timestamp.
    files = get_dir_timestamps(nm_path)

    # Check if &#39;ouis.txt&#39; needs to be downloaded.
    download = False
    if f&#39;{nm_path}/ouis.txt&#39; not in files:
        download = True
    else:
        delta = (dt.now().date() - files[f&#39;{nm_path}/ouis.txt&#39;].date()).days
        if delta &gt; 7:
            download = True

    # Download &#39;ouis.txt&#39;, if applicable.
    if download:
        download_ouis(f&#39;{nm_path}/ouis.txt&#39;)

    # Read &#39;ouis.txt&#39; and extract the base16 and vendor combinations.
    with open(f&#39;{nm_path}/ouis.txt&#39;, &#39;r&#39;) as txt:
        data = txt.read()
    pattern = &#39;.*base 16.*&#39;
    data = re.findall(pattern, data)
    data = [[_.split()[0], _.split(&#39;\t&#39;)[-1]] for _ in data]
    df = pd.DataFrame(data=data, columns=[&#39;base&#39;, &#39;vendor&#39;])

    return df</code></pre>
</details>
</dd>
<dt id="helpers.helpers.validate_table"><code class="name flex">
<span>def <span class="ident">validate_table</span></span>(<span>table: str, db_path: str, diff_col: List[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Validates a table, based on the columns that the user passes to the
function.</p>
<h2 id="args">Args</h2>
<p>table : str
The table to validate.
db_path : str
The path to the database.
diff_col : list of str
The column to diff. It should contain two items:
- item1: The column to diff (e.g., 'status').
- item2: The expected state (e.g., 'online').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_table(table: str, db_path: str, diff_col: List[str]) -&gt; None:
    &#39;&#39;&#39;
    Validates a table, based on the columns that the user passes to the
    function.

    Args:
        table : str
            The table to validate.
        db_path : str
            The path to the database.
        diff_col : list of str
            The column to diff. It should contain two items:
            - item1: The column to diff (e.g., &#39;status&#39;).
            - item2: The expected state (e.g., &#39;online&#39;).
    &#39;&#39;&#39;
    # Get the first and last timestamps from the table
    con = sl.connect(db_path)
    query = f&#39;select distinct timestamp from {table}&#39;
    df_stamps = pd.read_sql(query, con)
    stamps = df_stamps[&#39;timestamp&#39;].to_list()
    first_ts = stamps[0]
    last_ts = stamps[-1]

    # Execute the queries and diff the results
    query1 = f&#39;{diff_col[0]} = &#34;{diff_col[1]}&#34; and timestamp = &#34;{first_ts}&#34;&#39;
    query2 = f&#39;{diff_col[0]} = &#34;{diff_col[1]}&#34; and timestamp = &#34;{last_ts}&#34;&#39;
    query = f&#39;&#39;&#39;select *
                from {table}
                where {query1}
                except
                select *
                from {table}
                where {query2}
                &#39;&#39;&#39;
    df_diff = pd.read_sql(query, con)
    return df_diff</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="helpers" href="index.html">helpers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="helpers.helpers.ansible_create_collectors_df" href="#helpers.helpers.ansible_create_collectors_df">ansible_create_collectors_df</a></code></li>
<li><code><a title="helpers.helpers.ansible_create_vars_df" href="#helpers.helpers.ansible_create_vars_df">ansible_create_vars_df</a></code></li>
<li><code><a title="helpers.helpers.ansible_get_all_host_variables" href="#helpers.helpers.ansible_get_all_host_variables">ansible_get_all_host_variables</a></code></li>
<li><code><a title="helpers.helpers.ansible_get_all_hostgroup_os" href="#helpers.helpers.ansible_get_all_hostgroup_os">ansible_get_all_hostgroup_os</a></code></li>
<li><code><a title="helpers.helpers.ansible_get_host_variables" href="#helpers.helpers.ansible_get_host_variables">ansible_get_host_variables</a></code></li>
<li><code><a title="helpers.helpers.ansible_get_hostgroup" href="#helpers.helpers.ansible_get_hostgroup">ansible_get_hostgroup</a></code></li>
<li><code><a title="helpers.helpers.ansible_get_hostgroup_devices" href="#helpers.helpers.ansible_get_hostgroup_devices">ansible_get_hostgroup_devices</a></code></li>
<li><code><a title="helpers.helpers.ansible_get_hostgroups" href="#helpers.helpers.ansible_get_hostgroups">ansible_get_hostgroups</a></code></li>
<li><code><a title="helpers.helpers.ansible_group_hostgroups_by_os" href="#helpers.helpers.ansible_group_hostgroups_by_os">ansible_group_hostgroups_by_os</a></code></li>
<li><code><a title="helpers.helpers.check_dir_existence" href="#helpers.helpers.check_dir_existence">check_dir_existence</a></code></li>
<li><code><a title="helpers.helpers.connect_to_db" href="#helpers.helpers.connect_to_db">connect_to_db</a></code></li>
<li><code><a title="helpers.helpers.convert_mask_to_cidr" href="#helpers.helpers.convert_mask_to_cidr">convert_mask_to_cidr</a></code></li>
<li><code><a title="helpers.helpers.create_dir" href="#helpers.helpers.create_dir">create_dir</a></code></li>
<li><code><a title="helpers.helpers.create_sqlite_regexp_function" href="#helpers.helpers.create_sqlite_regexp_function">create_sqlite_regexp_function</a></code></li>
<li><code><a title="helpers.helpers.define_collectors" href="#helpers.helpers.define_collectors">define_collectors</a></code></li>
<li><code><a title="helpers.helpers.define_supported_validation_tables" href="#helpers.helpers.define_supported_validation_tables">define_supported_validation_tables</a></code></li>
<li><code><a title="helpers.helpers.download_ouis" href="#helpers.helpers.download_ouis">download_ouis</a></code></li>
<li><code><a title="helpers.helpers.f5_create_authentication_token" href="#helpers.helpers.f5_create_authentication_token">f5_create_authentication_token</a></code></li>
<li><code><a title="helpers.helpers.find_mac_vendors" href="#helpers.helpers.find_mac_vendors">find_mac_vendors</a></code></li>
<li><code><a title="helpers.helpers.generate_subnet_details" href="#helpers.helpers.generate_subnet_details">generate_subnet_details</a></code></li>
<li><code><a title="helpers.helpers.get_creds" href="#helpers.helpers.get_creds">get_creds</a></code></li>
<li><code><a title="helpers.helpers.get_database_tables" href="#helpers.helpers.get_database_tables">get_database_tables</a></code></li>
<li><code><a title="helpers.helpers.get_dir_timestamps" href="#helpers.helpers.get_dir_timestamps">get_dir_timestamps</a></code></li>
<li><code><a title="helpers.helpers.get_first_last_timestamp" href="#helpers.helpers.get_first_last_timestamp">get_first_last_timestamp</a></code></li>
<li><code><a title="helpers.helpers.get_net_manage_path" href="#helpers.helpers.get_net_manage_path">get_net_manage_path</a></code></li>
<li><code><a title="helpers.helpers.get_password" href="#helpers.helpers.get_password">get_password</a></code></li>
<li><code><a title="helpers.helpers.get_tests_file" href="#helpers.helpers.get_tests_file">get_tests_file</a></code></li>
<li><code><a title="helpers.helpers.get_user_meraki_input" href="#helpers.helpers.get_user_meraki_input">get_user_meraki_input</a></code></li>
<li><code><a title="helpers.helpers.get_username" href="#helpers.helpers.get_username">get_username</a></code></li>
<li><code><a title="helpers.helpers.meraki_check_api_enablement" href="#helpers.helpers.meraki_check_api_enablement">meraki_check_api_enablement</a></code></li>
<li><code><a title="helpers.helpers.meraki_get_api_key" href="#helpers.helpers.meraki_get_api_key">meraki_get_api_key</a></code></li>
<li><code><a title="helpers.helpers.meraki_map_network_to_organization" href="#helpers.helpers.meraki_map_network_to_organization">meraki_map_network_to_organization</a></code></li>
<li><code><a title="helpers.helpers.meraki_parse_organizations" href="#helpers.helpers.meraki_parse_organizations">meraki_parse_organizations</a></code></li>
<li><code><a title="helpers.helpers.move_cols_to_end" href="#helpers.helpers.move_cols_to_end">move_cols_to_end</a></code></li>
<li><code><a title="helpers.helpers.read_table" href="#helpers.helpers.read_table">read_table</a></code></li>
<li><code><a title="helpers.helpers.set_db_timestamp" href="#helpers.helpers.set_db_timestamp">set_db_timestamp</a></code></li>
<li><code><a title="helpers.helpers.set_dependencies" href="#helpers.helpers.set_dependencies">set_dependencies</a></code></li>
<li><code><a title="helpers.helpers.set_filepath" href="#helpers.helpers.set_filepath">set_filepath</a></code></li>
<li><code><a title="helpers.helpers.set_vars" href="#helpers.helpers.set_vars">set_vars</a></code></li>
<li><code><a title="helpers.helpers.sql_get_table_schema" href="#helpers.helpers.sql_get_table_schema">sql_get_table_schema</a></code></li>
<li><code><a title="helpers.helpers.suppress_extravars" href="#helpers.helpers.suppress_extravars">suppress_extravars</a></code></li>
<li><code><a title="helpers.helpers.tabulate_df_head" href="#helpers.helpers.tabulate_df_head">tabulate_df_head</a></code></li>
<li><code><a title="helpers.helpers.update_ouis" href="#helpers.helpers.update_ouis">update_ouis</a></code></li>
<li><code><a title="helpers.helpers.validate_table" href="#helpers.helpers.validate_table">validate_table</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>