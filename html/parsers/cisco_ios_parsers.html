<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>parsers.cisco_ios_parsers API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>parsers.cisco_ios_parsers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import pandas as pd
import re

from netmanage.helpers import helpers as hp


def parse_facts(runner: dict) -&gt; dict:
    &#34;&#34;&#34;Gathers specified facts on Cisco IOS devices.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    facts : dict
        A dictionary where each key is a device in the host_group and the value
        is the requested facts.
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Parse the output, store it in &#39;facts&#39;, and return it
    facts = dict()

    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]
            output = event_data[&#34;res&#34;][&#34;ansible_facts&#34;]

            facts[device] = output

    return facts


def parse_bgp_neighbors(runner):
    &#34;&#34;&#34;Parses the BGP neighbor summary output and returns it in a DataFrame.

    Parameters
    ----------
    runner : generator
        An Ansible runner generator.

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the BGP neighbor summary.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#39;The input is None or empty&#39;)

    rows = list()

    for event in runner.events:
        if event[&#39;event&#39;] == &#39;runner_on_ok&#39;:
            event_data = event[&#39;event_data&#39;]

            device = event_data[&#39;remote_addr&#39;]

            text = event_data[&#39;res&#39;][&#39;stdout&#39;][0]

            neighbors = text.split(&#34;BGP neighbor is&#34;)[1:]

            for neighbor in neighbors:
                local_host_search = re.search(
                    r&#34;Local host: (\d+\.\d+\.\d+\.\d+)&#34;, neighbor)
                local_host = local_host_search.group(1) \
                    if local_host_search else None
                bgp_neighbor = re.search(
                    r&#34;(\d+\.\d+\.\d+\.\d+)&#34;, neighbor).group(1)
                vrf_search = re.search(r&#34;vrf (\w+)&#34;, neighbor)
                vrf = vrf_search.group(1) if vrf_search else None
                local_as_search = re.search(r&#34;local AS (\d+)&#34;, neighbor)
                local_as = int(local_as_search.group(1)) \
                    if local_as_search else None
                remote_as = int(
                    re.search(r&#34;remote AS (\d+)&#34;, neighbor).group(1))
                peer_group_search = re.search(
                    r&#34;Member of peer-group ([\w+-]+)&#34;, neighbor)
                peer_group = peer_group_search.group(
                    1) if peer_group_search else None
                bgp_version = int(
                    re.search(r&#34;BGP version (\d+)&#34;, neighbor).group(1))
                neighbor_id = re.search(
                    r&#34;remote router ID (\d+\.\d+\.\d+\.\d+)&#34;, neighbor).\
                    group(1)
                bgp_state = re.search(r&#34;BGP state = (\w+)&#34;, neighbor).group(1)
                bgp_state_timer_search = re.search(
                    r&#34;BGP state = \w+, (.+)&#34;, neighbor)
                bgp_state_timer = bgp_state_timer_search.group(
                    1) if bgp_state_timer_search else None

                rows.append([device,
                             local_host,
                             bgp_neighbor,
                             vrf,
                             local_as,
                             remote_as,
                             peer_group,
                             bgp_version,
                             neighbor_id,
                             bgp_state,
                             bgp_state_timer])

    # Create DataFrame
    df = pd.DataFrame(rows, columns=[&#34;device&#34;,
                                     &#34;local_host&#34;,
                                     &#34;bgp_neighbor&#34;,
                                     &#34;vrf&#34;,
                                     &#34;local_as&#34;,
                                     &#34;remote_as&#34;,
                                     &#34;peer_group&#34;,
                                     &#34;bgp_version&#34;,
                                     &#34;neighbor_id&#34;,
                                     &#34;bgp_state&#34;,
                                     &#34;bgp_state_timer&#34;])

    return df


def parse_config(facts: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Parses the config on Cisco IOS devices.

    Parameters
    ----------
    facts : dict
        A dictionary where each key is a device in the host_group and the value
        is the requested facts.

    Returns
    -------
    df : pandas.DataFrame
        A DataFrame containing the device configurations.
    &#34;&#34;&#34;
    if facts is None or len(list(facts)) == 0:
        raise ValueError(&#34;The input is None or empty&#34;)

    configs = dict()
    for key, value in facts.items():
        configs[key] = value[&#34;ansible_net_config&#34;]

    df = pd.DataFrame(list(configs.items()), columns=[&#34;device&#34;, &#34;config&#34;])

    return df


def parse_ospf_neighbors(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Parses the OSPF neighbors output and returns it in a DataFrame.

    Parameters
    ----------
    runner : dict
        An Ansible runner generator.

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the OSPF neighbors.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#39;The input is None or empty&#39;)

    # Create the column headers.
    cols = [&#39;neighbor&#39;,
            &#39;neighbor_address&#39;,
            &#39;interface_id&#39;,
            &#39;area&#39;,
            &#39;interface&#39;,
            &#39;priority&#39;,
            &#39;state&#39;,
            &#39;state_changes&#39;,
            &#39;dead_timer&#39;,
            &#39;state_timer&#39;
            ]

    # Create a dictionary to store the parsed output.
    df_data = dict()
    df_data[&#39;device&#39;] = list()
    for col in cols:
        df_data[col] = list()

    # Parse the output, create the DataFrame and return it.
    for event in runner.events:
        if event[&#39;event&#39;] == &#39;runner_on_ok&#39;:
            event_data = event[&#39;event_data&#39;]

            device = event_data[&#39;remote_addr&#39;]

            output = event_data[&#39;res&#39;][&#39;stdout&#39;][0].split(&#39;\n&#39;)

            for line in output:
                if &#39;interface address&#39; in line:
                    df_data[&#39;device&#39;].append(device)
                    if len(line.split(&#39;,&#39;)) == 3:
                        df_data[&#39;interface_id&#39;].append(line.split()[-1])
                    else:
                        df_data[&#39;interface_id&#39;].append(&#39;&#39;)
                    line = line.split()
                    df_data[&#39;neighbor&#39;].append(line[1].strip(&#39;,&#39;))
                    df_data[&#39;neighbor_address&#39;].append(line[4].strip(&#39;,&#39;))
                if &#39;area&#39; in line:
                    line = line.split()
                    df_data[&#39;area&#39;].append(line[3])
                    df_data[&#39;interface&#39;].append(line[-1])
                if &#39;priority&#39; in line:
                    line = line.split()
                    df_data[&#39;priority&#39;].append(line[3].strip(&#39;,&#39;))
                    df_data[&#39;state&#39;].append(line[6].strip(&#39;,&#39;))
                    df_data[&#39;state_changes&#39;].append(line[-3])
                if &#39;Dead timer&#39; in line:
                    df_data[&#39;dead_timer&#39;].append(line.split()[-1])
                if &#39;for&#39; in line:
                    df_data[&#39;state_timer&#39;].append(line.split()[-1])

    # Create the dataframe and return it.
    df = pd.DataFrame(df_data).astype(str)

    return df


def parse_vrfs(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Retrieve VRF information and return it as a DataFrame.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    pandas.DataFrame
        A DataFrame containing VRF information, with columns [&#34;device&#34;, &#34;name&#34;,
        &#34;vrf_id&#34;, &#34;default_rd&#34;, &#34;default_vpn_id&#34;].
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create a dictionary to store the parsed output.
    df_data = dict()
    df_data[&#34;device&#34;] = list()
    df_data[&#34;Name&#34;] = list()
    df_data[&#34;Default RD&#34;] = list()
    df_data[&#34;Protocols&#34;] = list()
    df_data[&#34;Interfaces&#34;] = list()

    # Parse the output, create the DataFrame and return it.
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#39;res&#39;][&#39;stdout&#39;][0].split(&#39;\n&#39;)

            # Gather the header indexes.
            try:
                header = output[0]
                rd_pos = header.index(&#39;Default RD&#39;)
                proto_pos = header.index(&#39;Protocols&#39;)
                inf_pos = header.index(&#39;Interfaces&#39;)
            except Exception as e:
                if str(e) == &#39;substring not found&#39;:  # Raised if no VRFs.
                    pass
                else:
                    print(f&#39;{device}: {str(e)}&#39;)

            # Reverse &#39;output&#39; to make it easier to parse.
            output.reverse()

            # Parse the output.
            counter = 0
            for line in output:
                if len(line.split()) &gt; 1 and &#39;Default RD&#39; not in line:
                    interfaces = list()
                    name = line[:rd_pos].strip()
                    default_rd = line[rd_pos:proto_pos].strip()
                    protocols = line[proto_pos:inf_pos].strip()
                    interfaces.append(line[inf_pos:].strip())
                    pos = counter
                    # Collect additional interfaces for the VRF.
                    while len(output[pos+1].split()) &lt;= 1:
                        interfaces.append(output[pos+1].split()[0])
                        pos += 1
                    # Add the VRF to df_data.
                    df_data[&#39;device&#39;].append(device)
                    df_data[&#39;Name&#39;].append(name)
                    df_data[&#39;Default RD&#39;].append(default_rd)
                    df_data[&#39;Protocols&#39;].append(protocols)
                    df_data[&#39;Interfaces&#39;].append(interfaces)
                counter += 1

    # Create the dataframe then reverse it to preserve the original order.
    df = pd.DataFrame(df_data)
    df = df.iloc[::-1].reset_index(drop=True)

    # Convert the data in the &#39;Interfaces&#39; column from a list to a
    # space-delimited string.
    df[&#39;Interfaces&#39;] = df[&#39;Interfaces&#39;].apply(
        lambda x: &#39; &#39;.join(x)).astype(str)

    return df


def parse_ios_parse_uplink_by_ip(
        df_ip: pd.DataFrame, df_cdp: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Search the hostgroup for a list of subnets (use /32 to search for a
    single IP). Once it finds them, it uses CDP and LLDP (if applicable) to try
    to find the uplink.

    If a list of IP addresses is not provided, it will attempt to find the
    uplinks for all IP addresses on the devices.

    Parameters
    ----------
    df_ip: pd.DataFrame
        IP addresses on the devices in the host group.
    df_cdp: pd.DataFrame
        The CDP neighbors for the device.

    Returns
    -------
    df_combined : pd.DataFrame
        A DataFrame containing the IP to remote port mapping.

    Notes
    -----
    This is a simple function that was written for a single use case. It has
    some limitations:

    1. There is not an option to specify the VRF (although it will still return
       the uplinks for every IP that meets the parameters).
    2. If CDP and LLDP are disabled or the table is not populated, it does not
       try alternative methods like interface descriptions and CAM tables. I
       can add those if there is enough interest in this function.

    TODOs:
    - Add alternative methods if CDP and LLDP do not work:
      - Interface descriptions
      - Reverse DNS (in the case of P2P IPs)
      - CAM table
    - Add an option to specify the VRF (low priority).
    &#34;&#34;&#34;

    # Remove the sub-interfaces from df_ip
    local_infs = df_ip[&#34;Interface&#34;].to_list()
    local_infs = [inf.split(&#34;.&#34;)[0] for inf in local_infs]
    df_ip[&#34;Interface&#34;] = local_infs

    # Attempt to find the neighbors for the interfaces that have IPs
    df_data = list()

    for idx, row in df_ip.iterrows():
        device = row[&#34;Device&#34;]
        inf = row[&#34;Interface&#34;]
        neighbor_row = df_cdp.loc[
            (df_cdp[&#34;Device&#34;] == device) &amp; (df_cdp[&#34;Local Inf&#34;] == inf)
        ]
        remote_device = list(neighbor_row[&#34;Neighbor&#34;].values)
        if remote_device:
            remote_device = remote_device[0]
            remote_inf = list(neighbor_row[&#34;Remote Inf&#34;].values)[0]
        else:
            remote_device = &#34;unknown&#34;
            remote_inf = &#34;unknown&#34;
        mgmt_ip = row[&#34;IP&#34;]
        df_data.append([device, mgmt_ip, inf, remote_device, remote_inf])
    # Create a DataFrame and return it
    cols = [&#34;Device&#34;, &#34;IP&#34;, &#34;Local Interface&#34;,
            &#34;Remote Device&#34;, &#34;Remote Interface&#34;]
    df_combined = pd.DataFrame(data=df_data, columns=cols)

    return df_combined


def ios_parse_arp_table(runner: dict, nm_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the IOS ARP table and add the vendor OUI.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator
    nm_path : str
        The path to the Net-Manage repository.

    Returns
    -------
    df_arp : pd.DataFrame
        The ARP table and vendor OUI as a pandas DataFrame.
    &#34;&#34;&#34;

    if nm_path is None:
        raise ValueError(&#34;The input nm_path is None or empty&#34;)

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create the column headers. I do not like to hard code these, but they
    # should be modified from Cisco&#39;s format before being stored in a
    # database. I suppose it is not strictly necessary to do so, but
    # &#34;Age (min)&#34; and &#34;Hardware Addr&#34; do not make for good column headers.
    columns = [&#34;device&#34;, &#34;protocol&#34;, &#34;address&#34;,
               &#34;age&#34;, &#34;mac&#34;, &#34;inf_type&#34;, &#34;interface&#34;]

    # Parse the output and add it to &#39;data&#39;
    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)

            for line in output[1:]:
                row = [device] + line.split()
                df_data.append(row)

    # Create the DataFrame
    df_arp = pd.DataFrame(data=df_data, columns=columns)

    # Parses the vendor OUIs
    df_vendors = hp.find_mac_vendors(df_arp[&#34;mac&#34;], nm_path)

    # Add the vendor OUIs to df_cam as a column, and return the dataframe.
    df_arp[&#34;vendor&#34;] = df_vendors[&#34;vendor&#34;]

    return df_arp


def ios_parse_cam_table(runner: dict, nm_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the IOS CAM table and add the vendor OUI.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator
    nm_path : str
        The path to the Net-Manage repository.

    Returns
    -------
    df_cam : pd.DataFrame
        The CAM table and vendor OUI as a pandas DataFrame.
    &#34;&#34;&#34;

    if nm_path is None:
        raise ValueError(&#34;The input nm_path is None or empty&#34;)

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create the column headers. I do not like to hard code these, but they
    # should be modified from Cisco&#39;s format before being stored in a
    # database. I suppose it is not strictly necessary to do so, but
    # &#34;Mac Address&#34; and &#34;Type&#34; do not make good column headers.
    columns = [&#34;device&#34;, &#34;vlan&#34;, &#34;mac&#34;, &#34;inf_type&#34;, &#34;ports&#34;]

    # Parse the output and add it to &#39;data&#39;
    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            # columns = list(filter(None, output[0].split(&#39;  &#39;)))
            # columns.insert(0, &#39;device&#39;)
            # columns = [_.strip() for _ in columns]

            for line in output[2:-1]:
                row = [device] + line.split()
                df_data.append(row)

    # Create the DataFrame
    df_cam = pd.DataFrame(data=df_data, columns=columns)

    # Parses the vendor OUIs
    df_vendors = hp.find_mac_vendors(df_cam[&#34;mac&#34;], nm_path)

    # Add the vendor OUIs to df_cam as a column, and return the dataframe.
    df_cam[&#34;vendor&#34;] = df_vendors[&#34;vendor&#34;]

    return df_cam


def ios_parse_cdp_neighbors(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the CDP neighbors for a Cisco IOS device.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df_cdp : pd.DataFrame
        A DataFrame containing the CDP neighbors.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Parse the results
    cdp_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            pos = 1  # Used to account for multiple connections to same device
            for line in output:
                if &#34;Device ID&#34; in line:
                    remote_device = line.split(&#34;(&#34;)[0].split()[2].split(&#34;.&#34;)[0]
                    local_inf = output[pos].split()[1].strip(&#34;,&#34;)
                    remote_inf = output[pos].split()[-1]
                    row = [device, local_inf, remote_device, remote_inf]
                    cdp_data.append(row)
                pos += 1
    # Create a dataframe from cdp_data and return the results
    cols = [&#34;Device&#34;, &#34;Local Inf&#34;, &#34;Neighbor&#34;, &#34;Remote Inf&#34;]
    df_cdp = pd.DataFrame(data=cdp_data, columns=cols)
    return df_cdp


def ios_parse_interface_descriptions(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get IOS interface descriptions.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df_desc : pd.DataFrame
        A DataFrame containing the interface descriptions.
    &#34;&#34;&#34;

    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            # Parses the position of the &#39;Description&#39; column
            # (we cannot split by spaces because some
            # interface descriptions have spaces in them).
            pos = output[0].index(&#34;Description&#34;)
            for line in output[1:]:
                inf = line.split()[0]
                desc = line[pos:]
                df_data.append([device, inf, desc])

    # Create the dataframe and return it
    cols = [&#34;device&#34;, &#34;interface&#34;, &#34;description&#34;]
    df_desc = pd.DataFrame(data=df_data, columns=cols)
    return df_desc


def ios_parse_interface_ips(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the IP addresses assigned to interfaces.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the interfaces and IP addresses.
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Parse the results
    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            output.reverse()  # Reverse the output to make it easier to iterate
            counter = 0
            for line in output:
                if &#34;Internet address&#34; in line:
                    pos = counter
                    if &#34;VPN Routing/Forwarding&#34; in output[pos - 1]:
                        vrf = output[pos - 1].split()[-1].strip(&#39;&#34;&#39;)
                    else:
                        vrf = &#34;None&#34;
                    ip = line.split()[-1].split(&#39;/&#39;)[0]
                    inf = output[pos + 1].split()[0]
                    row = [device, inf, ip, vrf]
                    df_data.append(row)
                counter += 1

    # Create a dataframe from df_data and return it
    df_data.reverse()
    cols = [&#34;device&#34;, &#34;interface&#34;, &#34;ip&#34;, &#34;vrf&#34;]
    df = pd.DataFrame(data=df_data, columns=cols)

    # Add the subnets, network IPs, and broadcast IPs.
    addresses = df[&#34;ip&#34;].to_list()
    result = hp.generate_subnet_details(addresses)
    df[&#34;subnet&#34;] = result[&#34;subnet&#34;]
    df[&#34;network_ip&#34;] = result[&#34;network_ip&#34;]
    df[&#34;broadcast_ip&#34;] = result[&#34;broadcast_ip&#34;]

    # Add a column containing the CIDR notation.
    cidrs = hp.subnet_mask_to_cidr(df[&#34;subnet&#34;].to_list())
    df[&#39;cidr&#39;] = cidrs
    df = df[[&#39;device&#39;,
             &#39;interface&#39;,
             &#39;ip&#39;,
             &#39;cidr&#39;,
             &#39;vrf&#39;,
             &#39;subnet&#39;,
             &#39;network_ip&#39;,
             &#39;broadcast_ip&#39;]]

    return df


def ios_parse_inventory(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the inventory for Cisco IOS and IOS-XE devices.

    Parameters
    ----------
    runner : dict
        An Ansible runner generator.

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the inventory data.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create a dictionary to store the inventory data.
    columns = [&#39;device&#39;,
               &#39;name&#39;,
               &#39;description&#39;,
               &#39;pid&#39;,
               &#39;vid&#39;,
               &#39;serial&#39;]
    df_data = dict()
    for col in columns:
        df_data[col] = list()

    # Parse the output and add it to &#39;df_data&#39;
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            data = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)

            # Iterate through data (each hardware entry has 3 lines).
            for i in range(0, len(data), 3):
                df_data[&#39;device&#39;].append(device)
                # Split the first line to extract name and description
                name_desc = data[i].split(&#34;, DESCR: &#34;)
                df_data[&#39;name&#39;].append(
                    name_desc[0].replace(&#39;NAME: &#34;&#39;, &#39;&#39;).
                    replace(&#39;&#34;&#39;, &#39;&#39;).strip())
                df_data[&#39;description&#39;].append(
                    name_desc[1].replace(&#39;&#34;&#39;, &#39;&#39;).strip())

                # Split the second line to extract PID, VID and SN
                pid_vid_sn = data[i+1].split(&#34;, &#34;)
                df_data[&#39;pid&#39;].append(
                    pid_vid_sn[0].replace(&#39;PID: &#39;, &#39;&#39;).strip())
                df_data[&#39;vid&#39;].append(
                    pid_vid_sn[1].replace(&#39;VID: &#39;, &#39;&#39;).strip())

                # If SN value is &#34;SN:&#34;, replace with an empty string.
                sn_value = pid_vid_sn[2].replace(&#39;SN: &#39;, &#39;&#39;).strip()
                if sn_value == &#34;SN:&#34;:
                    sn_value = &#34;&#34;
                df_data[&#39;serial&#39;].append(sn_value)

    # Create the DataFrame and return it.
    df = pd.DataFrame(df_data)

    return df


def ios_parse_vlan_db(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the VLAN database for Cisco IOS devices.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the VLAN database.
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)

            # Create the column headers
            cols = [&#34;device&#34;] + output[0].split()[:3]
            cols = [_.lower() for _ in cols]

            # Removed wrapped interfaces
            output = [_ for _ in output[1:] if _[0] != &#34; &#34;]

            # Add the VLANs to &#39;df_data&#39;
            for line in output:
                row = [device] + line.split()[:3]
                df_data.append(row)

    # Create the dataframe and return it
    df = pd.DataFrame(data=df_data, columns=cols)
    return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="parsers.cisco_ios_parsers.ios_parse_arp_table"><code class="name flex">
<span>def <span class="ident">ios_parse_arp_table</span></span>(<span>runner: dict, nm_path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the IOS ARP table and add the vendor OUI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
<dt><strong><code>nm_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Net-Manage repository.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_arp</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The ARP table and vendor OUI as a pandas DataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_arp_table(runner: dict, nm_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the IOS ARP table and add the vendor OUI.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator
    nm_path : str
        The path to the Net-Manage repository.

    Returns
    -------
    df_arp : pd.DataFrame
        The ARP table and vendor OUI as a pandas DataFrame.
    &#34;&#34;&#34;

    if nm_path is None:
        raise ValueError(&#34;The input nm_path is None or empty&#34;)

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create the column headers. I do not like to hard code these, but they
    # should be modified from Cisco&#39;s format before being stored in a
    # database. I suppose it is not strictly necessary to do so, but
    # &#34;Age (min)&#34; and &#34;Hardware Addr&#34; do not make for good column headers.
    columns = [&#34;device&#34;, &#34;protocol&#34;, &#34;address&#34;,
               &#34;age&#34;, &#34;mac&#34;, &#34;inf_type&#34;, &#34;interface&#34;]

    # Parse the output and add it to &#39;data&#39;
    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)

            for line in output[1:]:
                row = [device] + line.split()
                df_data.append(row)

    # Create the DataFrame
    df_arp = pd.DataFrame(data=df_data, columns=columns)

    # Parses the vendor OUIs
    df_vendors = hp.find_mac_vendors(df_arp[&#34;mac&#34;], nm_path)

    # Add the vendor OUIs to df_cam as a column, and return the dataframe.
    df_arp[&#34;vendor&#34;] = df_vendors[&#34;vendor&#34;]

    return df_arp</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.ios_parse_cam_table"><code class="name flex">
<span>def <span class="ident">ios_parse_cam_table</span></span>(<span>runner: dict, nm_path: str) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the IOS CAM table and add the vendor OUI.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
<dt><strong><code>nm_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the Net-Manage repository.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_cam</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The CAM table and vendor OUI as a pandas DataFrame.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_cam_table(runner: dict, nm_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the IOS CAM table and add the vendor OUI.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator
    nm_path : str
        The path to the Net-Manage repository.

    Returns
    -------
    df_cam : pd.DataFrame
        The CAM table and vendor OUI as a pandas DataFrame.
    &#34;&#34;&#34;

    if nm_path is None:
        raise ValueError(&#34;The input nm_path is None or empty&#34;)

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create the column headers. I do not like to hard code these, but they
    # should be modified from Cisco&#39;s format before being stored in a
    # database. I suppose it is not strictly necessary to do so, but
    # &#34;Mac Address&#34; and &#34;Type&#34; do not make good column headers.
    columns = [&#34;device&#34;, &#34;vlan&#34;, &#34;mac&#34;, &#34;inf_type&#34;, &#34;ports&#34;]

    # Parse the output and add it to &#39;data&#39;
    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            # columns = list(filter(None, output[0].split(&#39;  &#39;)))
            # columns.insert(0, &#39;device&#39;)
            # columns = [_.strip() for _ in columns]

            for line in output[2:-1]:
                row = [device] + line.split()
                df_data.append(row)

    # Create the DataFrame
    df_cam = pd.DataFrame(data=df_data, columns=columns)

    # Parses the vendor OUIs
    df_vendors = hp.find_mac_vendors(df_cam[&#34;mac&#34;], nm_path)

    # Add the vendor OUIs to df_cam as a column, and return the dataframe.
    df_cam[&#34;vendor&#34;] = df_vendors[&#34;vendor&#34;]

    return df_cam</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.ios_parse_cdp_neighbors"><code class="name flex">
<span>def <span class="ident">ios_parse_cdp_neighbors</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the CDP neighbors for a Cisco IOS device.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_cdp</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the CDP neighbors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_cdp_neighbors(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the CDP neighbors for a Cisco IOS device.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df_cdp : pd.DataFrame
        A DataFrame containing the CDP neighbors.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Parse the results
    cdp_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            pos = 1  # Used to account for multiple connections to same device
            for line in output:
                if &#34;Device ID&#34; in line:
                    remote_device = line.split(&#34;(&#34;)[0].split()[2].split(&#34;.&#34;)[0]
                    local_inf = output[pos].split()[1].strip(&#34;,&#34;)
                    remote_inf = output[pos].split()[-1]
                    row = [device, local_inf, remote_device, remote_inf]
                    cdp_data.append(row)
                pos += 1
    # Create a dataframe from cdp_data and return the results
    cols = [&#34;Device&#34;, &#34;Local Inf&#34;, &#34;Neighbor&#34;, &#34;Remote Inf&#34;]
    df_cdp = pd.DataFrame(data=cdp_data, columns=cols)
    return df_cdp</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.ios_parse_interface_descriptions"><code class="name flex">
<span>def <span class="ident">ios_parse_interface_descriptions</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Get IOS interface descriptions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_desc</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the interface descriptions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_interface_descriptions(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Get IOS interface descriptions.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df_desc : pd.DataFrame
        A DataFrame containing the interface descriptions.
    &#34;&#34;&#34;

    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            # Parses the position of the &#39;Description&#39; column
            # (we cannot split by spaces because some
            # interface descriptions have spaces in them).
            pos = output[0].index(&#34;Description&#34;)
            for line in output[1:]:
                inf = line.split()[0]
                desc = line[pos:]
                df_data.append([device, inf, desc])

    # Create the dataframe and return it
    cols = [&#34;device&#34;, &#34;interface&#34;, &#34;description&#34;]
    df_desc = pd.DataFrame(data=df_data, columns=cols)
    return df_desc</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.ios_parse_interface_ips"><code class="name flex">
<span>def <span class="ident">ios_parse_interface_ips</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the IP addresses assigned to interfaces.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the interfaces and IP addresses.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_interface_ips(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the IP addresses assigned to interfaces.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the interfaces and IP addresses.
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Parse the results
    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)
            output.reverse()  # Reverse the output to make it easier to iterate
            counter = 0
            for line in output:
                if &#34;Internet address&#34; in line:
                    pos = counter
                    if &#34;VPN Routing/Forwarding&#34; in output[pos - 1]:
                        vrf = output[pos - 1].split()[-1].strip(&#39;&#34;&#39;)
                    else:
                        vrf = &#34;None&#34;
                    ip = line.split()[-1].split(&#39;/&#39;)[0]
                    inf = output[pos + 1].split()[0]
                    row = [device, inf, ip, vrf]
                    df_data.append(row)
                counter += 1

    # Create a dataframe from df_data and return it
    df_data.reverse()
    cols = [&#34;device&#34;, &#34;interface&#34;, &#34;ip&#34;, &#34;vrf&#34;]
    df = pd.DataFrame(data=df_data, columns=cols)

    # Add the subnets, network IPs, and broadcast IPs.
    addresses = df[&#34;ip&#34;].to_list()
    result = hp.generate_subnet_details(addresses)
    df[&#34;subnet&#34;] = result[&#34;subnet&#34;]
    df[&#34;network_ip&#34;] = result[&#34;network_ip&#34;]
    df[&#34;broadcast_ip&#34;] = result[&#34;broadcast_ip&#34;]

    # Add a column containing the CIDR notation.
    cidrs = hp.subnet_mask_to_cidr(df[&#34;subnet&#34;].to_list())
    df[&#39;cidr&#39;] = cidrs
    df = df[[&#39;device&#39;,
             &#39;interface&#39;,
             &#39;ip&#39;,
             &#39;cidr&#39;,
             &#39;vrf&#39;,
             &#39;subnet&#39;,
             &#39;network_ip&#39;,
             &#39;broadcast_ip&#39;]]

    return df</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.ios_parse_inventory"><code class="name flex">
<span>def <span class="ident">ios_parse_inventory</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the inventory for Cisco IOS and IOS-XE devices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the inventory data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_inventory(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the inventory for Cisco IOS and IOS-XE devices.

    Parameters
    ----------
    runner : dict
        An Ansible runner generator.

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the inventory data.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create a dictionary to store the inventory data.
    columns = [&#39;device&#39;,
               &#39;name&#39;,
               &#39;description&#39;,
               &#39;pid&#39;,
               &#39;vid&#39;,
               &#39;serial&#39;]
    df_data = dict()
    for col in columns:
        df_data[col] = list()

    # Parse the output and add it to &#39;df_data&#39;
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            data = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)

            # Iterate through data (each hardware entry has 3 lines).
            for i in range(0, len(data), 3):
                df_data[&#39;device&#39;].append(device)
                # Split the first line to extract name and description
                name_desc = data[i].split(&#34;, DESCR: &#34;)
                df_data[&#39;name&#39;].append(
                    name_desc[0].replace(&#39;NAME: &#34;&#39;, &#39;&#39;).
                    replace(&#39;&#34;&#39;, &#39;&#39;).strip())
                df_data[&#39;description&#39;].append(
                    name_desc[1].replace(&#39;&#34;&#39;, &#39;&#39;).strip())

                # Split the second line to extract PID, VID and SN
                pid_vid_sn = data[i+1].split(&#34;, &#34;)
                df_data[&#39;pid&#39;].append(
                    pid_vid_sn[0].replace(&#39;PID: &#39;, &#39;&#39;).strip())
                df_data[&#39;vid&#39;].append(
                    pid_vid_sn[1].replace(&#39;VID: &#39;, &#39;&#39;).strip())

                # If SN value is &#34;SN:&#34;, replace with an empty string.
                sn_value = pid_vid_sn[2].replace(&#39;SN: &#39;, &#39;&#39;).strip()
                if sn_value == &#34;SN:&#34;:
                    sn_value = &#34;&#34;
                df_data[&#39;serial&#39;].append(sn_value)

    # Create the DataFrame and return it.
    df = pd.DataFrame(df_data)

    return df</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.ios_parse_vlan_db"><code class="name flex">
<span>def <span class="ident">ios_parse_vlan_db</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the VLAN database for Cisco IOS devices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the VLAN database.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ios_parse_vlan_db(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Parses the VLAN database for Cisco IOS devices.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the VLAN database.
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    df_data = list()
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#34;res&#34;][&#34;stdout&#34;][0].split(&#34;\n&#34;)

            # Create the column headers
            cols = [&#34;device&#34;] + output[0].split()[:3]
            cols = [_.lower() for _ in cols]

            # Removed wrapped interfaces
            output = [_ for _ in output[1:] if _[0] != &#34; &#34;]

            # Add the VLANs to &#39;df_data&#39;
            for line in output:
                row = [device] + line.split()[:3]
                df_data.append(row)

    # Create the dataframe and return it
    df = pd.DataFrame(data=df_data, columns=cols)
    return df</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.parse_bgp_neighbors"><code class="name flex">
<span>def <span class="ident">parse_bgp_neighbors</span></span>(<span>runner)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the BGP neighbor summary output and returns it in a DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>generator</code></dt>
<dd>An Ansible runner generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the BGP neighbor summary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_bgp_neighbors(runner):
    &#34;&#34;&#34;Parses the BGP neighbor summary output and returns it in a DataFrame.

    Parameters
    ----------
    runner : generator
        An Ansible runner generator.

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the BGP neighbor summary.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#39;The input is None or empty&#39;)

    rows = list()

    for event in runner.events:
        if event[&#39;event&#39;] == &#39;runner_on_ok&#39;:
            event_data = event[&#39;event_data&#39;]

            device = event_data[&#39;remote_addr&#39;]

            text = event_data[&#39;res&#39;][&#39;stdout&#39;][0]

            neighbors = text.split(&#34;BGP neighbor is&#34;)[1:]

            for neighbor in neighbors:
                local_host_search = re.search(
                    r&#34;Local host: (\d+\.\d+\.\d+\.\d+)&#34;, neighbor)
                local_host = local_host_search.group(1) \
                    if local_host_search else None
                bgp_neighbor = re.search(
                    r&#34;(\d+\.\d+\.\d+\.\d+)&#34;, neighbor).group(1)
                vrf_search = re.search(r&#34;vrf (\w+)&#34;, neighbor)
                vrf = vrf_search.group(1) if vrf_search else None
                local_as_search = re.search(r&#34;local AS (\d+)&#34;, neighbor)
                local_as = int(local_as_search.group(1)) \
                    if local_as_search else None
                remote_as = int(
                    re.search(r&#34;remote AS (\d+)&#34;, neighbor).group(1))
                peer_group_search = re.search(
                    r&#34;Member of peer-group ([\w+-]+)&#34;, neighbor)
                peer_group = peer_group_search.group(
                    1) if peer_group_search else None
                bgp_version = int(
                    re.search(r&#34;BGP version (\d+)&#34;, neighbor).group(1))
                neighbor_id = re.search(
                    r&#34;remote router ID (\d+\.\d+\.\d+\.\d+)&#34;, neighbor).\
                    group(1)
                bgp_state = re.search(r&#34;BGP state = (\w+)&#34;, neighbor).group(1)
                bgp_state_timer_search = re.search(
                    r&#34;BGP state = \w+, (.+)&#34;, neighbor)
                bgp_state_timer = bgp_state_timer_search.group(
                    1) if bgp_state_timer_search else None

                rows.append([device,
                             local_host,
                             bgp_neighbor,
                             vrf,
                             local_as,
                             remote_as,
                             peer_group,
                             bgp_version,
                             neighbor_id,
                             bgp_state,
                             bgp_state_timer])

    # Create DataFrame
    df = pd.DataFrame(rows, columns=[&#34;device&#34;,
                                     &#34;local_host&#34;,
                                     &#34;bgp_neighbor&#34;,
                                     &#34;vrf&#34;,
                                     &#34;local_as&#34;,
                                     &#34;remote_as&#34;,
                                     &#34;peer_group&#34;,
                                     &#34;bgp_version&#34;,
                                     &#34;neighbor_id&#34;,
                                     &#34;bgp_state&#34;,
                                     &#34;bgp_state_timer&#34;])

    return df</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.parse_config"><code class="name flex">
<span>def <span class="ident">parse_config</span></span>(<span>facts: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the config on Cisco IOS devices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>facts</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary where each key is a device in the host_group and the value
is the requested facts.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A DataFrame containing the device configurations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_config(facts: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Parses the config on Cisco IOS devices.

    Parameters
    ----------
    facts : dict
        A dictionary where each key is a device in the host_group and the value
        is the requested facts.

    Returns
    -------
    df : pandas.DataFrame
        A DataFrame containing the device configurations.
    &#34;&#34;&#34;
    if facts is None or len(list(facts)) == 0:
        raise ValueError(&#34;The input is None or empty&#34;)

    configs = dict()
    for key, value in facts.items():
        configs[key] = value[&#34;ansible_net_config&#34;]

    df = pd.DataFrame(list(configs.items()), columns=[&#34;device&#34;, &#34;config&#34;])

    return df</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.parse_facts"><code class="name flex">
<span>def <span class="ident">parse_facts</span></span>(<span>runner: dict) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Gathers specified facts on Cisco IOS devices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>facts</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary where each key is a device in the host_group and the value
is the requested facts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_facts(runner: dict) -&gt; dict:
    &#34;&#34;&#34;Gathers specified facts on Cisco IOS devices.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    facts : dict
        A dictionary where each key is a device in the host_group and the value
        is the requested facts.
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Parse the output, store it in &#39;facts&#39;, and return it
    facts = dict()

    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]
            output = event_data[&#34;res&#34;][&#34;ansible_facts&#34;]

            facts[device] = output

    return facts</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.parse_ios_parse_uplink_by_ip"><code class="name flex">
<span>def <span class="ident">parse_ios_parse_uplink_by_ip</span></span>(<span>df_ip: pandas.core.frame.DataFrame, df_cdp: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Search the hostgroup for a list of subnets (use /32 to search for a
single IP). Once it finds them, it uses CDP and LLDP (if applicable) to try
to find the uplink.</p>
<p>If a list of IP addresses is not provided, it will attempt to find the
uplinks for all IP addresses on the devices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df_ip</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>IP addresses on the devices in the host group.</dd>
<dt><strong><code>df_cdp</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The CDP neighbors for the device.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df_combined</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the IP to remote port mapping.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This is a simple function that was written for a single use case. It has
some limitations:</p>
<ol>
<li>There is not an option to specify the VRF (although it will still return
the uplinks for every IP that meets the parameters).</li>
<li>If CDP and LLDP are disabled or the table is not populated, it does not
try alternative methods like interface descriptions and CAM tables. I
can add those if there is enough interest in this function.</li>
</ol>
<p>TODOs:
- Add alternative methods if CDP and LLDP do not work:
- Interface descriptions
- Reverse DNS (in the case of P2P IPs)
- CAM table
- Add an option to specify the VRF (low priority).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_ios_parse_uplink_by_ip(
        df_ip: pd.DataFrame, df_cdp: pd.DataFrame) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Search the hostgroup for a list of subnets (use /32 to search for a
    single IP). Once it finds them, it uses CDP and LLDP (if applicable) to try
    to find the uplink.

    If a list of IP addresses is not provided, it will attempt to find the
    uplinks for all IP addresses on the devices.

    Parameters
    ----------
    df_ip: pd.DataFrame
        IP addresses on the devices in the host group.
    df_cdp: pd.DataFrame
        The CDP neighbors for the device.

    Returns
    -------
    df_combined : pd.DataFrame
        A DataFrame containing the IP to remote port mapping.

    Notes
    -----
    This is a simple function that was written for a single use case. It has
    some limitations:

    1. There is not an option to specify the VRF (although it will still return
       the uplinks for every IP that meets the parameters).
    2. If CDP and LLDP are disabled or the table is not populated, it does not
       try alternative methods like interface descriptions and CAM tables. I
       can add those if there is enough interest in this function.

    TODOs:
    - Add alternative methods if CDP and LLDP do not work:
      - Interface descriptions
      - Reverse DNS (in the case of P2P IPs)
      - CAM table
    - Add an option to specify the VRF (low priority).
    &#34;&#34;&#34;

    # Remove the sub-interfaces from df_ip
    local_infs = df_ip[&#34;Interface&#34;].to_list()
    local_infs = [inf.split(&#34;.&#34;)[0] for inf in local_infs]
    df_ip[&#34;Interface&#34;] = local_infs

    # Attempt to find the neighbors for the interfaces that have IPs
    df_data = list()

    for idx, row in df_ip.iterrows():
        device = row[&#34;Device&#34;]
        inf = row[&#34;Interface&#34;]
        neighbor_row = df_cdp.loc[
            (df_cdp[&#34;Device&#34;] == device) &amp; (df_cdp[&#34;Local Inf&#34;] == inf)
        ]
        remote_device = list(neighbor_row[&#34;Neighbor&#34;].values)
        if remote_device:
            remote_device = remote_device[0]
            remote_inf = list(neighbor_row[&#34;Remote Inf&#34;].values)[0]
        else:
            remote_device = &#34;unknown&#34;
            remote_inf = &#34;unknown&#34;
        mgmt_ip = row[&#34;IP&#34;]
        df_data.append([device, mgmt_ip, inf, remote_device, remote_inf])
    # Create a DataFrame and return it
    cols = [&#34;Device&#34;, &#34;IP&#34;, &#34;Local Interface&#34;,
            &#34;Remote Device&#34;, &#34;Remote Interface&#34;]
    df_combined = pd.DataFrame(data=df_data, columns=cols)

    return df_combined</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.parse_ospf_neighbors"><code class="name flex">
<span>def <span class="ident">parse_ospf_neighbors</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Parses the OSPF neighbors output and returns it in a DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>A DataFrame containing the OSPF neighbors.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_ospf_neighbors(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Parses the OSPF neighbors output and returns it in a DataFrame.

    Parameters
    ----------
    runner : dict
        An Ansible runner generator.

    Returns
    -------
    df : pd.DataFrame
        A DataFrame containing the OSPF neighbors.
    &#34;&#34;&#34;
    if runner is None or runner.events is None:
        raise ValueError(&#39;The input is None or empty&#39;)

    # Create the column headers.
    cols = [&#39;neighbor&#39;,
            &#39;neighbor_address&#39;,
            &#39;interface_id&#39;,
            &#39;area&#39;,
            &#39;interface&#39;,
            &#39;priority&#39;,
            &#39;state&#39;,
            &#39;state_changes&#39;,
            &#39;dead_timer&#39;,
            &#39;state_timer&#39;
            ]

    # Create a dictionary to store the parsed output.
    df_data = dict()
    df_data[&#39;device&#39;] = list()
    for col in cols:
        df_data[col] = list()

    # Parse the output, create the DataFrame and return it.
    for event in runner.events:
        if event[&#39;event&#39;] == &#39;runner_on_ok&#39;:
            event_data = event[&#39;event_data&#39;]

            device = event_data[&#39;remote_addr&#39;]

            output = event_data[&#39;res&#39;][&#39;stdout&#39;][0].split(&#39;\n&#39;)

            for line in output:
                if &#39;interface address&#39; in line:
                    df_data[&#39;device&#39;].append(device)
                    if len(line.split(&#39;,&#39;)) == 3:
                        df_data[&#39;interface_id&#39;].append(line.split()[-1])
                    else:
                        df_data[&#39;interface_id&#39;].append(&#39;&#39;)
                    line = line.split()
                    df_data[&#39;neighbor&#39;].append(line[1].strip(&#39;,&#39;))
                    df_data[&#39;neighbor_address&#39;].append(line[4].strip(&#39;,&#39;))
                if &#39;area&#39; in line:
                    line = line.split()
                    df_data[&#39;area&#39;].append(line[3])
                    df_data[&#39;interface&#39;].append(line[-1])
                if &#39;priority&#39; in line:
                    line = line.split()
                    df_data[&#39;priority&#39;].append(line[3].strip(&#39;,&#39;))
                    df_data[&#39;state&#39;].append(line[6].strip(&#39;,&#39;))
                    df_data[&#39;state_changes&#39;].append(line[-3])
                if &#39;Dead timer&#39; in line:
                    df_data[&#39;dead_timer&#39;].append(line.split()[-1])
                if &#39;for&#39; in line:
                    df_data[&#39;state_timer&#39;].append(line.split()[-1])

    # Create the dataframe and return it.
    df = pd.DataFrame(df_data).astype(str)

    return df</code></pre>
</details>
</dd>
<dt id="parsers.cisco_ios_parsers.parse_vrfs"><code class="name flex">
<span>def <span class="ident">parse_vrfs</span></span>(<span>runner: dict) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve VRF information and return it as a DataFrame.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>runner</code></strong> :&ensp;<code>dict</code></dt>
<dd>An Ansible runner genrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pandas.DataFrame</code></dt>
<dd>A DataFrame containing VRF information, with columns ["device", "name",
"vrf_id", "default_rd", "default_vpn_id"].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_vrfs(runner: dict) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Retrieve VRF information and return it as a DataFrame.

    Parameters
    ----------
    runner : dict
        An Ansible runner genrator

    Returns
    -------
    pandas.DataFrame
        A DataFrame containing VRF information, with columns [&#34;device&#34;, &#34;name&#34;,
        &#34;vrf_id&#34;, &#34;default_rd&#34;, &#34;default_vpn_id&#34;].
    &#34;&#34;&#34;

    if runner is None or runner.events is None:
        raise ValueError(&#34;The input is None or empty&#34;)

    # Create a dictionary to store the parsed output.
    df_data = dict()
    df_data[&#34;device&#34;] = list()
    df_data[&#34;Name&#34;] = list()
    df_data[&#34;Default RD&#34;] = list()
    df_data[&#34;Protocols&#34;] = list()
    df_data[&#34;Interfaces&#34;] = list()

    # Parse the output, create the DataFrame and return it.
    for event in runner.events:
        if event[&#34;event&#34;] == &#34;runner_on_ok&#34;:
            event_data = event[&#34;event_data&#34;]

            device = event_data[&#34;remote_addr&#34;]

            output = event_data[&#39;res&#39;][&#39;stdout&#39;][0].split(&#39;\n&#39;)

            # Gather the header indexes.
            try:
                header = output[0]
                rd_pos = header.index(&#39;Default RD&#39;)
                proto_pos = header.index(&#39;Protocols&#39;)
                inf_pos = header.index(&#39;Interfaces&#39;)
            except Exception as e:
                if str(e) == &#39;substring not found&#39;:  # Raised if no VRFs.
                    pass
                else:
                    print(f&#39;{device}: {str(e)}&#39;)

            # Reverse &#39;output&#39; to make it easier to parse.
            output.reverse()

            # Parse the output.
            counter = 0
            for line in output:
                if len(line.split()) &gt; 1 and &#39;Default RD&#39; not in line:
                    interfaces = list()
                    name = line[:rd_pos].strip()
                    default_rd = line[rd_pos:proto_pos].strip()
                    protocols = line[proto_pos:inf_pos].strip()
                    interfaces.append(line[inf_pos:].strip())
                    pos = counter
                    # Collect additional interfaces for the VRF.
                    while len(output[pos+1].split()) &lt;= 1:
                        interfaces.append(output[pos+1].split()[0])
                        pos += 1
                    # Add the VRF to df_data.
                    df_data[&#39;device&#39;].append(device)
                    df_data[&#39;Name&#39;].append(name)
                    df_data[&#39;Default RD&#39;].append(default_rd)
                    df_data[&#39;Protocols&#39;].append(protocols)
                    df_data[&#39;Interfaces&#39;].append(interfaces)
                counter += 1

    # Create the dataframe then reverse it to preserve the original order.
    df = pd.DataFrame(df_data)
    df = df.iloc[::-1].reset_index(drop=True)

    # Convert the data in the &#39;Interfaces&#39; column from a list to a
    # space-delimited string.
    df[&#39;Interfaces&#39;] = df[&#39;Interfaces&#39;].apply(
        lambda x: &#39; &#39;.join(x)).astype(str)

    return df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="parsers" href="index.html">parsers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_arp_table" href="#parsers.cisco_ios_parsers.ios_parse_arp_table">ios_parse_arp_table</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_cam_table" href="#parsers.cisco_ios_parsers.ios_parse_cam_table">ios_parse_cam_table</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_cdp_neighbors" href="#parsers.cisco_ios_parsers.ios_parse_cdp_neighbors">ios_parse_cdp_neighbors</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_interface_descriptions" href="#parsers.cisco_ios_parsers.ios_parse_interface_descriptions">ios_parse_interface_descriptions</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_interface_ips" href="#parsers.cisco_ios_parsers.ios_parse_interface_ips">ios_parse_interface_ips</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_inventory" href="#parsers.cisco_ios_parsers.ios_parse_inventory">ios_parse_inventory</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.ios_parse_vlan_db" href="#parsers.cisco_ios_parsers.ios_parse_vlan_db">ios_parse_vlan_db</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.parse_bgp_neighbors" href="#parsers.cisco_ios_parsers.parse_bgp_neighbors">parse_bgp_neighbors</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.parse_config" href="#parsers.cisco_ios_parsers.parse_config">parse_config</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.parse_facts" href="#parsers.cisco_ios_parsers.parse_facts">parse_facts</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.parse_ios_parse_uplink_by_ip" href="#parsers.cisco_ios_parsers.parse_ios_parse_uplink_by_ip">parse_ios_parse_uplink_by_ip</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.parse_ospf_neighbors" href="#parsers.cisco_ios_parsers.parse_ospf_neighbors">parse_ospf_neighbors</a></code></li>
<li><code><a title="parsers.cisco_ios_parsers.parse_vrfs" href="#parsers.cisco_ios_parsers.parse_vrfs">parse_vrfs</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>